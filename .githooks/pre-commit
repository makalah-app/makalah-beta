#!/usr/bin/env bash
set -euo pipefail

# Makalah AI pre-commit secret scanner
# - Runs gitleaks/secretlint when available
# - Falls back to lightweight rg-based scanner on staged content
# - Skip with: SKIP_SECRET_CHECK=1 git commit -m "..."

if [[ "${SKIP_SECRET_CHECK:-0}" == "1" ]]; then
  echo "[secret-scan] Skipped via SKIP_SECRET_CHECK=1"
  exit 0
fi

# Collect staged files (Added/Copied/Modified)
# Using while-read loop for bash 3.2 compatibility (mapfile introduced in bash 4.0)
STAGED_FILES=()
while IFS= read -r file; do
  STAGED_FILES+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACM)

if [[ ${#STAGED_FILES[@]} -eq 0 ]]; then
  exit 0
fi

echo "[secret-scan] Scanning staged changes for secrets..."

# Prefer gitleaks if installed
if command -v gitleaks >/dev/null 2>&1; then
  cfg=".gitleaks.toml"
  if [[ -f "gitleaks.toml" && ! -f "$cfg" ]]; then cfg="gitleaks.toml"; fi
  echo "[secret-scan] Using gitleaks"
  if ! gitleaks detect --staged --no-banner --redact --config-path "$cfg"; then
    echo >&2 "\n[secret-scan] ❌ Gitleaks found potential secrets. Fix or set SKIP_SECRET_CHECK=1 to bypass."
    exit 1
  fi
  exit 0
fi

# Try secretlint if installed
if command -v secretlint >/dev/null 2>&1 && [[ -f .secretlintrc.json ]]; then
  echo "[secret-scan] Using secretlint"
  if ! secretlint "${STAGED_FILES[@]}"; then
    echo >&2 "\n[secret-scan] ❌ Secretlint found potential secrets. Fix or set SKIP_SECRET_CHECK=1 to bypass."
    exit 1
  fi
  exit 0
fi

# Fallback lightweight scanner using ripgrep on staged content only
if ! command -v rg >/dev/null 2>&1; then
  echo "[secret-scan] rg not found, skipping fallback scan"
  exit 0
fi

# Paths to ignore for fallback (examples/placeholders)
IGNORES=( \
  '^docs/' \
  '^__references__/' \
  '^node_modules/' \
  '^.next/' \
  '^.codex/' \
  '^.claude/' \
  '^supabase/.temp/' \
  '^tests/' \
  '^playwright-report/' \
  '^test-results/' \
  '^coverage/' \
  '^environments/.env.development$' \
  '^.env.example$' \
)

function is_ignored_path() {
  local f="$1"
  for p in "${IGNORES[@]}"; do
    if [[ "$f" =~ $p ]]; then return 0; fi
  done
  return 1
}

# PCRE patterns for common secrets
PATTERN='(sk-(proj-)?[A-Za-z0-9_-]{24,}'
PATTERN+='|sk-or-(v1-)?[A-Za-z0-9_-]{24,}'
PATTERN+='|ghp_[A-Za-z0-9]{20,}'
PATTERN+='|pplx-[A-Za-z0-9]+'
PATTERN+='|vck_[A-Za-z0-9]+'
PATTERN+='|AKIA[0-9A-Z]{16}'
PATTERN+='|ASIA[0-9A-Z]{16}'
PATTERN+='|AIza[0-9A-Za-z-_]{35}'
PATTERN+='|eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+'
PATTERN+='|postgresql://[A-Za-z0-9._%+-]+:[^@\n]+@'
PATTERN+='|mongodb(\+srv)?:\/\/'
PATTERN+='|rediss?:\/\/'
PATTERN+='|smtps?:\/\/'
PATTERN+='|Authorization:\s*Bearer\s+[A-Za-z0-9._-]+)'

FOUND=0
for f in "${STAGED_FILES[@]}"; do
  # skip deletes and ignored paths
  if ! git ls-files --error-unmatch -- "$f" >/dev/null 2>&1; then continue; fi
  if is_ignored_path "$f"; then continue; fi

  # read staged content and scan
  if git show ":$f" | rg -n --pcre2 "$PATTERN" >/dev/null; then
    echo "[secret-scan] Potential secret in: $f" >&2
    git show ":$f" | rg -n --pcre2 "$PATTERN" | head -5 | sed 's/^/  > /' >&2
    FOUND=1
  fi
done

if [[ $FOUND -eq 1 ]]; then
  echo >&2 "\n[secret-scan] ❌ Potential secrets detected in staged changes."
  echo >&2 "Fix before commit, or export SKIP_SECRET_CHECK=1 to bypass (not recommended)."
  exit 1
fi

echo "[secret-scan] ✅ No secrets detected in staged changes"
exit 0

