-- Migration: Security Validation Tests and Performance Assessment
-- Description: Comprehensive test suite dan performance monitoring untuk RLS policies
-- Author: Database Security Architect
-- Date: 2025-01-25
-- Task: 08 - Row Level Security Implementation

-- =====================================================
-- SECURITY TEST FUNCTIONS
-- =====================================================

-- Function to test user data isolation
CREATE OR REPLACE FUNCTION security_tests.test_user_data_isolation() 
RETURNS TABLE (
    test_name TEXT,
    test_result BOOLEAN,
    test_description TEXT,
    error_message TEXT
) AS $$
DECLARE
    test_user_1_id UUID := gen_random_uuid();
    test_user_2_id UUID := gen_random_uuid();
    test_workflow_id UUID := gen_random_uuid();
    isolation_test_passed BOOLEAN;
    current_test TEXT;
    current_error TEXT;
BEGIN
    -- Test 1: Users cannot see other users' data
    current_test := 'user_profile_isolation';
    current_error := NULL;
    BEGIN
        -- Simulate different user contexts (this would be done via JWT in practice)
        -- Test if user can access another user's profile
        SELECT COUNT(*) = 0 INTO isolation_test_passed
        FROM public.users
        WHERE id = test_user_2_id; -- This should fail if RLS is working
        
        test_name := current_test;
        test_result := isolation_test_passed;
        test_description := 'Users cannot access other users profiles';
        error_message := current_error;
        RETURN NEXT;
    EXCEPTION
        WHEN OTHERS THEN
            test_name := current_test;
            test_result := false;
            test_description := 'Users cannot access other users profiles';
            error_message := SQLERRM;
            RETURN NEXT;
    END;
    
    -- Test 2: Workflow ownership validation
    current_test := 'workflow_ownership';
    current_error := NULL;
    BEGIN
        -- Test workflow access restrictions
        SELECT auth.can_access_workflow(test_workflow_id) INTO isolation_test_passed;
        
        test_name := current_test;
        test_result := NOT isolation_test_passed; -- Should be false for non-existent workflow
        test_description := 'Workflow access properly restricted to owners';
        error_message := current_error;
        RETURN NEXT;
    EXCEPTION
        WHEN OTHERS THEN
            test_name := current_test;
            test_result := false;
            test_description := 'Workflow access properly restricted to owners';
            error_message := SQLERRM;
            RETURN NEXT;
    END;
    
    -- Test 3: Session validation
    current_test := 'session_validation';
    current_error := NULL;
    BEGIN
        -- Test session validation logic
        SELECT auth.validate_session_integrity() INTO isolation_test_passed;
        
        test_name := current_test;
        test_result := NOT isolation_test_passed; -- Should fail without proper session
        test_description := 'Session validation works correctly';
        error_message := current_error;
        RETURN NEXT;
    EXCEPTION
        WHEN OTHERS THEN
            test_name := current_test;
            test_result := false;
            test_description := 'Session validation works correctly';
            error_message := SQLERRM;
            RETURN NEXT;
    END;
    
    -- Test 4: Admin permission checks
    current_test := 'admin_permissions';
    current_error := NULL;
    BEGIN
        -- Test admin permission validation
        SELECT auth.can_perform_admin_action('user_management'::admin_action_category) INTO isolation_test_passed;
        
        test_name := current_test;
        test_result := NOT isolation_test_passed; -- Should fail for non-admin
        test_description := 'Admin permissions properly validated';
        error_message := current_error;
        RETURN NEXT;
    EXCEPTION
        WHEN OTHERS THEN
            test_name := current_test;
            test_result := false;
            test_description := 'Admin permissions properly validated';
            error_message := SQLERRM;
            RETURN NEXT;
    END;
    
    -- Test 5: File access validation
    current_test := 'file_access_validation';
    current_error := NULL;
    BEGIN
        -- Test file access restrictions
        SELECT auth.can_access_file('artifacts/test-user-id/test-file.pdf') INTO isolation_test_passed;
        
        test_name := current_test;
        test_result := NOT isolation_test_passed; -- Should fail without proper access
        test_description := 'File access properly restricted';
        error_message := current_error;
        RETURN NEXT;
    EXCEPTION
        WHEN OTHERS THEN
            test_name := current_test;
            test_result := false;
            test_description := 'File access properly restricted';
            error_message := SQLERRM;
            RETURN NEXT;
    END;
END;
$$ LANGUAGE plpgsql;

-- Function to test RLS policy performance
CREATE OR REPLACE FUNCTION security_tests.test_rls_performance()
RETURNS TABLE (
    policy_name TEXT,
    table_name TEXT,
    operation_type TEXT,
    execution_time_ms NUMERIC,
    rows_affected INTEGER,
    performance_rating TEXT
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    execution_duration NUMERIC;
    test_count INTEGER := 1000;
    affected_rows INTEGER;
BEGIN
    -- Test 1: Users table SELECT performance
    start_time := clock_timestamp();
    FOR i IN 1..test_count LOOP
        SELECT COUNT(*) INTO affected_rows FROM public.users WHERE id = auth.user_id();
    END LOOP;
    end_time := clock_timestamp();
    
    execution_duration := EXTRACT(MILLISECONDS FROM end_time - start_time);
    
    policy_name := 'users_select_own_profile';
    table_name := 'users';
    operation_type := 'SELECT';
    execution_time_ms := execution_duration;
    rows_affected := affected_rows;
    performance_rating := CASE
        WHEN execution_duration < 100 THEN 'EXCELLENT'
        WHEN execution_duration < 500 THEN 'GOOD'
        WHEN execution_duration < 1000 THEN 'ACCEPTABLE'
        ELSE 'NEEDS_OPTIMIZATION'
    END;
    RETURN NEXT;
    
    -- Test 2: Workflows table SELECT performance
    start_time := clock_timestamp();
    FOR i IN 1..test_count LOOP
        SELECT COUNT(*) INTO affected_rows FROM public.workflows WHERE user_id = auth.user_id();
    END LOOP;
    end_time := clock_timestamp();
    
    execution_duration := EXTRACT(MILLISECONDS FROM end_time - start_time);
    
    policy_name := 'workflows_select_own';
    table_name := 'workflows';
    operation_type := 'SELECT';
    execution_time_ms := execution_duration;
    rows_affected := affected_rows;
    performance_rating := CASE
        WHEN execution_duration < 100 THEN 'EXCELLENT'
        WHEN execution_duration < 500 THEN 'GOOD'
        WHEN execution_duration < 1000 THEN 'ACCEPTABLE'
        ELSE 'NEEDS_OPTIMIZATION'
    END;
    RETURN NEXT;
    
    -- Test 3: Artifacts table SELECT performance
    start_time := clock_timestamp();
    FOR i IN 1..test_count LOOP
        SELECT COUNT(*) INTO affected_rows FROM public.artifacts WHERE user_id = auth.user_id();
    END LOOP;
    end_time := clock_timestamp();
    
    execution_duration := EXTRACT(MILLISECONDS FROM end_time - start_time);
    
    policy_name := 'artifacts_select_own_workflow';
    table_name := 'artifacts';
    operation_type := 'SELECT';
    execution_time_ms := execution_duration;
    rows_affected := affected_rows;
    performance_rating := CASE
        WHEN execution_duration < 200 THEN 'EXCELLENT'
        WHEN execution_duration < 800 THEN 'GOOD'
        WHEN execution_duration < 1500 THEN 'ACCEPTABLE'
        ELSE 'NEEDS_OPTIMIZATION'
    END;
    RETURN NEXT;
    
    -- Test 4: Session validation performance
    start_time := clock_timestamp();
    FOR i IN 1..test_count LOOP
        PERFORM auth.validate_session_integrity();
    END LOOP;
    end_time := clock_timestamp();
    
    execution_duration := EXTRACT(MILLISECONDS FROM end_time - start_time);
    
    policy_name := 'session_validation';
    table_name := 'user_sessions';
    operation_type := 'FUNCTION';
    execution_time_ms := execution_duration;
    rows_affected := 0;
    performance_rating := CASE
        WHEN execution_duration < 300 THEN 'EXCELLENT'
        WHEN execution_duration < 1000 THEN 'GOOD'
        WHEN execution_duration < 2000 THEN 'ACCEPTABLE'
        ELSE 'NEEDS_OPTIMIZATION'
    END;
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;

-- Function to analyze RLS policy coverage
CREATE OR REPLACE FUNCTION security_tests.analyze_rls_coverage()
RETURNS TABLE (
    schema_name TEXT,
    table_name TEXT,
    rls_enabled BOOLEAN,
    policy_count INTEGER,
    has_select_policy BOOLEAN,
    has_insert_policy BOOLEAN,
    has_update_policy BOOLEAN,
    has_delete_policy BOOLEAN,
    coverage_rating TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        n.nspname::TEXT,
        c.relname::TEXT,
        c.relrowsecurity as rls_enabled,
        COUNT(p.polname)::INTEGER as policy_count,
        COUNT(p.polname) FILTER (WHERE p.polcmd = 'r') > 0 as has_select_policy,
        COUNT(p.polname) FILTER (WHERE p.polcmd = 'a') > 0 as has_insert_policy,
        COUNT(p.polname) FILTER (WHERE p.polcmd = 'w') > 0 as has_update_policy,
        COUNT(p.polname) FILTER (WHERE p.polcmd = 'd') > 0 as has_delete_policy,
        CASE 
            WHEN NOT c.relrowsecurity THEN 'NO_RLS'
            WHEN COUNT(p.polname) = 0 THEN 'NO_POLICIES'
            WHEN COUNT(p.polname) FILTER (WHERE p.polcmd IN ('r', 'a', 'w', 'd')) >= 3 THEN 'GOOD_COVERAGE'
            WHEN COUNT(p.polname) FILTER (WHERE p.polcmd IN ('r', 'a', 'w', 'd')) >= 2 THEN 'PARTIAL_COVERAGE'
            ELSE 'MINIMAL_COVERAGE'
        END as coverage_rating
    FROM pg_class c
    JOIN pg_namespace n ON c.relnamespace = n.oid
    LEFT JOIN pg_policy p ON p.polrelid = c.oid
    WHERE n.nspname = 'public'
    AND c.relkind = 'r'
    AND c.relname NOT LIKE 'pg_%'
    GROUP BY n.nspname, c.relname, c.relrowsecurity
    ORDER BY coverage_rating DESC, c.relname;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- SECURITY MONITORING AND ALERTING
-- =====================================================

-- Function to detect suspicious activity patterns
CREATE OR REPLACE FUNCTION security_monitor.detect_suspicious_activity()
RETURNS TABLE (
    user_email TEXT,
    user_id UUID,
    alert_type TEXT,
    alert_severity TEXT,
    alert_description TEXT,
    occurrences INTEGER,
    first_occurrence TIMESTAMPTZ,
    last_occurrence TIMESTAMPTZ
) AS $$
BEGIN
    -- Multiple failed authentication attempts
    RETURN QUERY
    SELECT 
        u.email,
        sal.user_id,
        'multiple_auth_failures'::TEXT,
        'HIGH'::TEXT,
        'Multiple authentication failures detected'::TEXT,
        COUNT(*)::INTEGER,
        MIN(sal.created_at),
        MAX(sal.created_at)
    FROM public.security_audit_log sal
    JOIN public.users u ON sal.user_id = u.id
    WHERE sal.success = false
    AND sal.action_type LIKE '%auth%'
    AND sal.created_at > NOW() - INTERVAL '1 hour'
    GROUP BY u.email, sal.user_id
    HAVING COUNT(*) >= 5;
    
    -- Unusual file access patterns
    RETURN QUERY
    SELECT 
        u.email,
        sal.user_id,
        'unusual_file_access'::TEXT,
        'MEDIUM'::TEXT,
        'Unusual file access pattern detected'::TEXT,
        COUNT(*)::INTEGER,
        MIN(sal.created_at),
        MAX(sal.created_at)
    FROM public.security_audit_log sal
    JOIN public.users u ON sal.user_id = u.id
    WHERE sal.action_type = 'file_access'
    AND sal.success = false
    AND sal.created_at > NOW() - INTERVAL '30 minutes'
    GROUP BY u.email, sal.user_id
    HAVING COUNT(*) >= 10;
    
    -- Admin privilege escalations
    RETURN QUERY
    SELECT 
        u.email,
        sal.user_id,
        'admin_privilege_escalation'::TEXT,
        'HIGH'::TEXT,
        'Admin privilege escalation detected'::TEXT,
        COUNT(*)::INTEGER,
        MIN(sal.created_at),
        MAX(sal.created_at)
    FROM public.security_audit_log sal
    JOIN public.users u ON sal.user_id = u.id
    WHERE sal.action_type = 'super_admin_privilege_escalation'
    AND sal.created_at > NOW() - INTERVAL '24 hours'
    GROUP BY u.email, sal.user_id;
    
    -- Session anomalies
    RETURN QUERY
    SELECT 
        u.email,
        sal.user_id,
        'session_anomaly'::TEXT,
        'MEDIUM'::TEXT,
        'Session anomaly detected'::TEXT,
        COUNT(*)::INTEGER,
        MIN(sal.created_at),
        MAX(sal.created_at)
    FROM public.security_audit_log sal
    JOIN public.users u ON sal.user_id = u.id
    WHERE sal.action_type = 'session_limit_exceeded'
    AND sal.created_at > NOW() - INTERVAL '2 hours'
    GROUP BY u.email, sal.user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to generate comprehensive security report
CREATE OR REPLACE FUNCTION security_monitor.generate_security_report(
    start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '7 days',
    end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
    section TEXT,
    metric_name TEXT,
    metric_value TEXT,
    status TEXT,
    recommendations TEXT
) AS $$
DECLARE
    total_users INTEGER;
    active_sessions INTEGER;
    failed_auths INTEGER;
    admin_actions INTEGER;
    file_access_attempts INTEGER;
    rls_coverage_score NUMERIC;
BEGIN
    -- Get metrics
    SELECT COUNT(*) INTO total_users FROM public.users WHERE is_active = true;
    SELECT COUNT(*) INTO active_sessions FROM public.user_sessions WHERE is_active = true AND expires_at > NOW();
    SELECT COUNT(*) INTO failed_auths FROM public.security_audit_log WHERE success = false AND created_at BETWEEN start_date AND end_date;
    SELECT COUNT(*) INTO admin_actions FROM public.security_audit_log WHERE action_type = 'admin_action' AND created_at BETWEEN start_date AND end_date;
    SELECT COUNT(*) INTO file_access_attempts FROM public.security_audit_log WHERE action_type = 'file_access' AND created_at BETWEEN start_date AND end_date;
    
    -- Calculate RLS coverage score
    SELECT AVG(CASE 
        WHEN coverage_rating = 'GOOD_COVERAGE' THEN 100
        WHEN coverage_rating = 'PARTIAL_COVERAGE' THEN 70
        WHEN coverage_rating = 'MINIMAL_COVERAGE' THEN 40
        WHEN coverage_rating = 'NO_POLICIES' THEN 10
        ELSE 0
    END) INTO rls_coverage_score
    FROM security_tests.analyze_rls_coverage()
    WHERE rls_enabled = true;
    
    -- User metrics
    section := 'User Management';
    metric_name := 'Total Active Users';
    metric_value := total_users::TEXT;
    status := CASE WHEN total_users > 0 THEN 'OK' ELSE 'WARNING' END;
    recommendations := CASE WHEN total_users = 0 THEN 'No active users found' ELSE 'User management operational' END;
    RETURN NEXT;
    
    -- Session metrics
    section := 'Session Security';
    metric_name := 'Active Sessions';
    metric_value := active_sessions::TEXT;
    status := CASE 
        WHEN active_sessions > total_users * 2 THEN 'WARNING'
        WHEN active_sessions > 0 THEN 'OK'
        ELSE 'INFO'
    END;
    recommendations := CASE 
        WHEN active_sessions > total_users * 2 THEN 'High number of concurrent sessions detected'
        ELSE 'Session management within normal parameters'
    END;
    RETURN NEXT;
    
    -- Authentication metrics
    section := 'Authentication';
    metric_name := 'Failed Authentication Attempts';
    metric_value := failed_auths::TEXT;
    status := CASE 
        WHEN failed_auths > 100 THEN 'CRITICAL'
        WHEN failed_auths > 20 THEN 'WARNING'
        ELSE 'OK'
    END;
    recommendations := CASE 
        WHEN failed_auths > 100 THEN 'High number of failed authentications - investigate potential attacks'
        WHEN failed_auths > 20 THEN 'Elevated authentication failures - monitor closely'
        ELSE 'Authentication security within normal parameters'
    END;
    RETURN NEXT;
    
    -- Admin activity metrics
    section := 'Admin Activity';
    metric_name := 'Admin Actions';
    metric_value := admin_actions::TEXT;
    status := CASE 
        WHEN admin_actions > 1000 THEN 'INFO'
        WHEN admin_actions > 0 THEN 'OK'
        ELSE 'INFO'
    END;
    recommendations := CASE 
        WHEN admin_actions > 1000 THEN 'High admin activity - ensure proper authorization'
        ELSE 'Admin activity tracking operational'
    END;
    RETURN NEXT;
    
    -- File access metrics
    section := 'File Security';
    metric_name := 'File Access Attempts';
    metric_value := file_access_attempts::TEXT;
    status := 'OK';
    recommendations := 'File access monitoring operational';
    RETURN NEXT;
    
    -- RLS coverage metrics
    section := 'Database Security';
    metric_name := 'RLS Policy Coverage';
    metric_value := ROUND(rls_coverage_score, 1)::TEXT || '%';
    status := CASE 
        WHEN rls_coverage_score >= 90 THEN 'EXCELLENT'
        WHEN rls_coverage_score >= 70 THEN 'GOOD'
        WHEN rls_coverage_score >= 50 THEN 'ACCEPTABLE'
        ELSE 'NEEDS_IMPROVEMENT'
    END;
    recommendations := CASE 
        WHEN rls_coverage_score >= 90 THEN 'RLS coverage excellent'
        WHEN rls_coverage_score >= 70 THEN 'RLS coverage good - minor improvements possible'
        WHEN rls_coverage_score >= 50 THEN 'RLS coverage acceptable - consider additional policies'
        ELSE 'RLS coverage needs improvement - implement missing policies'
    END;
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- PERFORMANCE OPTIMIZATION RECOMMENDATIONS
-- =====================================================

-- Function to identify performance optimization opportunities
CREATE OR REPLACE FUNCTION security_monitor.get_performance_recommendations()
RETURNS TABLE (
    category TEXT,
    recommendation TEXT,
    priority TEXT,
    estimated_impact TEXT,
    implementation_notes TEXT
) AS $$
BEGIN
    -- Check for missing indexes on RLS-related columns
    RETURN QUERY
    SELECT 
        'Indexing'::TEXT,
        'Add index on user_id columns for better RLS performance'::TEXT,
        'HIGH'::TEXT,
        'Significant query performance improvement'::TEXT,
        'CREATE INDEX IF NOT EXISTS idx_table_user_id ON table_name(user_id);'::TEXT;
    
    -- Check for complex RLS policies
    RETURN QUERY
    SELECT 
        'Policy Optimization'::TEXT,
        'Simplify complex RLS policies with function calls'::TEXT,
        'MEDIUM'::TEXT,
        'Reduced policy evaluation time'::TEXT,
        'Consider caching results of expensive policy functions'::TEXT;
    
    -- Check for audit log growth
    RETURN QUERY
    SELECT 
        'Data Management'::TEXT,
        'Implement audit log archival for old security events'::TEXT,
        'MEDIUM'::TEXT,
        'Reduced table size and improved query performance'::TEXT,
        'Archive security_audit_log entries older than 90 days'::TEXT;
    
    -- Check for session cleanup
    RETURN QUERY
    SELECT 
        'Session Management'::TEXT,
        'Implement automated expired session cleanup'::TEXT,
        'LOW'::TEXT,
        'Better session table performance'::TEXT,
        'Schedule regular cleanup of expired sessions'::TEXT;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- CREATE SCHEMA FOR SECURITY FUNCTIONS
-- =====================================================

-- Create schemas for organization
CREATE SCHEMA IF NOT EXISTS security_tests;
CREATE SCHEMA IF NOT EXISTS security_monitor;

-- Grant appropriate permissions
GRANT USAGE ON SCHEMA security_tests TO authenticated;
GRANT USAGE ON SCHEMA security_monitor TO authenticated;

-- =====================================================
-- AUTOMATED TESTING SCHEDULE
-- =====================================================

-- Function to run all security tests
CREATE OR REPLACE FUNCTION security_tests.run_all_security_tests()
RETURNS TABLE (
    test_suite TEXT,
    tests_passed INTEGER,
    tests_failed INTEGER,
    overall_status TEXT,
    execution_time TEXT
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    passed_count INTEGER;
    failed_count INTEGER;
BEGIN
    start_time := clock_timestamp();
    
    -- Run isolation tests
    SELECT COUNT(*) FILTER (WHERE test_result = true), COUNT(*) FILTER (WHERE test_result = false)
    INTO passed_count, failed_count
    FROM security_tests.test_user_data_isolation();
    
    end_time := clock_timestamp();
    
    test_suite := 'User Data Isolation';
    tests_passed := passed_count;
    tests_failed := failed_count;
    overall_status := CASE WHEN failed_count = 0 THEN 'PASSED' ELSE 'FAILED' END;
    execution_time := EXTRACT(MILLISECONDS FROM end_time - start_time)::TEXT || ' ms';
    RETURN NEXT;
    
    -- Additional test suites can be added here
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- COMMENTS AND DOCUMENTATION
-- =====================================================

COMMENT ON SCHEMA security_tests IS 'Schema containing security test functions';
COMMENT ON SCHEMA security_monitor IS 'Schema containing security monitoring functions';

COMMENT ON FUNCTION security_tests.test_user_data_isolation() IS 'Tests user data isolation policies';
COMMENT ON FUNCTION security_tests.test_rls_performance() IS 'Performance testing for RLS policies';
COMMENT ON FUNCTION security_tests.analyze_rls_coverage() IS 'Analyzes RLS policy coverage across tables';
COMMENT ON FUNCTION security_monitor.detect_suspicious_activity() IS 'Detects suspicious security activity patterns';
COMMENT ON FUNCTION security_monitor.generate_security_report() IS 'Generates comprehensive security status report';
COMMENT ON FUNCTION security_monitor.get_performance_recommendations() IS 'Provides performance optimization recommendations';
COMMENT ON FUNCTION security_tests.run_all_security_tests() IS 'Runs complete security test suite';