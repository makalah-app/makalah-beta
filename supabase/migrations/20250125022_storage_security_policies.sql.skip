-- Migration: Storage Security Policies Implementation
-- Description: Comprehensive storage policies dan security functions untuk artifact protection
-- Author: Database Security Architect
-- Date: 2025-01-25  
-- Task: 08 - Row Level Security Implementation

-- =====================================================
-- SECURITY FUNCTIONS FOR AUTHENTICATION VALIDATION
-- =====================================================

-- Function to validate user authentication comprehensively
CREATE OR REPLACE FUNCTION auth.validate_user_authentication() RETURNS BOOLEAN AS $$
DECLARE
    user_uuid UUID;
    user_record RECORD;
    session_valid BOOLEAN;
BEGIN
    user_uuid := auth.user_id();
    
    -- Check if user ID exists
    IF user_uuid IS NULL THEN
        RETURN false;
    END IF;
    
    -- Check JWT expiration
    IF auth.is_jwt_expired() THEN
        RETURN false;
    END IF;
    
    -- Get user details
    SELECT id, is_active, locked_until, email_verified_at
    INTO user_record
    FROM public.users
    WHERE id = user_uuid;
    
    -- User must exist, be active, not locked, and email verified
    IF NOT FOUND OR 
       NOT user_record.is_active OR
       (user_record.locked_until IS NOT NULL AND user_record.locked_until > NOW()) OR
       user_record.email_verified_at IS NULL THEN
        RETURN false;
    END IF;
    
    -- Validate session integrity if available
    session_valid := auth.validate_session_integrity();
    
    RETURN session_valid;
EXCEPTION
    WHEN OTHERS THEN
        RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user can access specific file
CREATE OR REPLACE FUNCTION auth.can_access_file(file_path TEXT) RETURNS BOOLEAN AS $$
DECLARE
    user_uuid UUID;
    bucket_name TEXT;
    file_segments TEXT[];
    artifact_record RECORD;
    workflow_access BOOLEAN := false;
BEGIN
    user_uuid := auth.user_id();
    
    -- Must be authenticated
    IF NOT auth.validate_user_authentication() THEN
        RETURN false;
    END IF;
    
    -- Parse file path to get bucket and segments
    file_segments := string_to_array(file_path, '/');
    bucket_name := file_segments[1];
    
    -- Handle different bucket access patterns
    CASE bucket_name
        WHEN 'avatars' THEN
            -- User avatars: only owner can access
            RETURN file_segments[2] = user_uuid::TEXT;
            
        WHEN 'artifacts' THEN
            -- Artifact files: check ownership through artifacts table
            SELECT user_id, workflow_id, is_public INTO artifact_record
            FROM public.artifacts
            WHERE file_path = file_path;
            
            IF FOUND THEN
                -- Public artifacts are accessible to all authenticated users
                IF artifact_record.is_public THEN
                    RETURN true;
                END IF;
                
                -- Check ownership or workflow access
                workflow_access := (
                    artifact_record.user_id = user_uuid OR
                    auth.can_access_workflow(artifact_record.workflow_id) OR
                    auth.can_perform_admin_action('artifact_management'::admin_action_category)
                );
                
                RETURN workflow_access;
            END IF;
            
        WHEN 'documents' THEN
            -- General documents: user folder access
            RETURN file_segments[2] = user_uuid::TEXT;
            
        WHEN 'templates' THEN
            -- Templates: public access for authenticated users
            RETURN true;
            
        WHEN 'system' THEN
            -- System files: admin only
            RETURN auth.can_perform_admin_action('system_configuration'::admin_action_category);
            
        ELSE
            -- Unknown bucket: deny access
            RETURN false;
    END CASE;
    
    RETURN false;
EXCEPTION
    WHEN OTHERS THEN
        RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to validate file upload permissions
CREATE OR REPLACE FUNCTION auth.can_upload_file(
    bucket_name TEXT,
    file_path TEXT,
    file_size BIGINT DEFAULT NULL,
    mime_type TEXT DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
    user_uuid UUID;
    file_segments TEXT[];
    max_file_size BIGINT;
    allowed_mime_types TEXT[];
    user_storage_used BIGINT;
    user_storage_limit BIGINT := 1073741824; -- 1GB default
BEGIN
    user_uuid := auth.user_id();
    
    -- Must be authenticated
    IF NOT auth.validate_user_authentication() THEN
        RETURN false;
    END IF;
    
    file_segments := string_to_array(file_path, '/');
    
    -- Set bucket-specific limits
    CASE bucket_name
        WHEN 'avatars' THEN
            max_file_size := 5242880; -- 5MB
            allowed_mime_types := ARRAY['image/jpeg', 'image/png', 'image/webp'];
            -- Must be uploading to own user folder
            IF file_segments[2] != user_uuid::TEXT THEN
                RETURN false;
            END IF;
            
        WHEN 'artifacts' THEN
            max_file_size := 104857600; -- 100MB
            allowed_mime_types := ARRAY[
                'application/pdf',
                'text/plain',
                'text/markdown',
                'application/json',
                'text/csv',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            ];
            
        WHEN 'documents' THEN
            max_file_size := 52428800; -- 50MB
            allowed_mime_types := ARRAY[
                'application/pdf',
                'text/plain',
                'text/markdown',
                'application/json',
                'image/jpeg',
                'image/png'
            ];
            -- Must be uploading to own user folder
            IF file_segments[2] != user_uuid::TEXT THEN
                RETURN false;
            END IF;
            
        WHEN 'templates' THEN
            -- Only admins can upload templates
            IF NOT auth.can_perform_admin_action('system_configuration'::admin_action_category) THEN
                RETURN false;
            END IF;
            max_file_size := 20971520; -- 20MB
            allowed_mime_types := ARRAY[
                'text/plain',
                'text/markdown',
                'application/json',
                'text/html'
            ];
            
        WHEN 'system' THEN
            -- Only system admins can upload system files
            IF auth.get_admin_permission_level() != 'super_admin' THEN
                RETURN false;
            END IF;
            max_file_size := 209715200; -- 200MB
            allowed_mime_types := ARRAY['application/octet-stream'];
            
        ELSE
            RETURN false;
    END CASE;
    
    -- Validate file size
    IF file_size IS NOT NULL AND file_size > max_file_size THEN
        RETURN false;
    END IF;
    
    -- Validate MIME type
    IF mime_type IS NOT NULL AND NOT (mime_type = ANY(allowed_mime_types)) THEN
        RETURN false;
    END IF;
    
    -- Check user storage quota (for non-admin uploads)
    IF bucket_name IN ('avatars', 'documents') THEN
        -- Calculate current storage usage
        SELECT COALESCE(SUM(file_size), 0) INTO user_storage_used
        FROM public.artifacts
        WHERE user_id = user_uuid
        AND status != 'deleted';
        
        -- Check if adding new file would exceed quota
        IF user_storage_used + COALESCE(file_size, 0) > user_storage_limit THEN
            RETURN false;
        END IF;
    END IF;
    
    RETURN true;
EXCEPTION
    WHEN OTHERS THEN
        RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to log file access attempts
CREATE OR REPLACE FUNCTION auth.log_file_access(
    file_path TEXT,
    access_type TEXT, -- 'read', 'write', 'delete'
    success BOOLEAN DEFAULT true,
    error_msg TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
    user_uuid UUID;
    log_id UUID;
BEGIN
    user_uuid := auth.user_id();
    
    log_id := auth.log_security_event(
        'file_access',
        user_uuid,
        NULL,
        NULL,
        NULL,
        success,
        error_msg,
        jsonb_build_object(
            'file_path', file_path,
            'access_type', access_type,
            'bucket', split_part(file_path, '/', 1)
        )
    );
    
    RETURN log_id;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- STORAGE BUCKET POLICIES
-- =====================================================

-- Create storage bucket policies using Supabase Storage RLS

-- Avatars bucket policies
CREATE POLICY "avatars_select_own" ON storage.objects
    FOR SELECT
    TO authenticated
    USING (
        bucket_id = 'avatars' AND
        auth.can_access_file(name)
    );

CREATE POLICY "avatars_insert_own" ON storage.objects
    FOR INSERT
    TO authenticated
    WITH CHECK (
        bucket_id = 'avatars' AND
        auth.can_upload_file('avatars', name, metadata->>'size'::BIGINT, metadata->>'mimetype')
    );

CREATE POLICY "avatars_update_own" ON storage.objects
    FOR UPDATE
    TO authenticated
    USING (
        bucket_id = 'avatars' AND
        auth.can_access_file(name)
    )
    WITH CHECK (
        bucket_id = 'avatars' AND
        auth.can_access_file(name)
    );

CREATE POLICY "avatars_delete_own" ON storage.objects
    FOR DELETE
    TO authenticated
    USING (
        bucket_id = 'avatars' AND
        auth.can_access_file(name)
    );

-- Artifacts bucket policies
CREATE POLICY "artifacts_select_authorized" ON storage.objects
    FOR SELECT
    TO authenticated
    USING (
        bucket_id = 'artifacts' AND
        auth.can_access_file(name)
    );

CREATE POLICY "artifacts_insert_authorized" ON storage.objects
    FOR INSERT
    TO authenticated
    WITH CHECK (
        bucket_id = 'artifacts' AND
        auth.can_upload_file('artifacts', name, metadata->>'size'::BIGINT, metadata->>'mimetype')
    );

CREATE POLICY "artifacts_update_authorized" ON storage.objects
    FOR UPDATE
    TO authenticated
    USING (
        bucket_id = 'artifacts' AND
        auth.can_access_file(name)
    )
    WITH CHECK (
        bucket_id = 'artifacts' AND
        auth.can_access_file(name)
    );

CREATE POLICY "artifacts_delete_authorized" ON storage.objects
    FOR DELETE
    TO authenticated
    USING (
        bucket_id = 'artifacts' AND
        auth.can_access_file(name)
    );

-- Documents bucket policies
CREATE POLICY "documents_select_own" ON storage.objects
    FOR SELECT
    TO authenticated
    USING (
        bucket_id = 'documents' AND
        auth.can_access_file(name)
    );

CREATE POLICY "documents_insert_own" ON storage.objects
    FOR INSERT
    TO authenticated
    WITH CHECK (
        bucket_id = 'documents' AND
        auth.can_upload_file('documents', name, metadata->>'size'::BIGINT, metadata->>'mimetype')
    );

CREATE POLICY "documents_update_own" ON storage.objects
    FOR UPDATE
    TO authenticated
    USING (
        bucket_id = 'documents' AND
        auth.can_access_file(name)
    )
    WITH CHECK (
        bucket_id = 'documents' AND
        auth.can_access_file(name)
    );

CREATE POLICY "documents_delete_own" ON storage.objects
    FOR DELETE
    TO authenticated
    USING (
        bucket_id = 'documents' AND
        auth.can_access_file(name)
    );

-- Templates bucket policies
CREATE POLICY "templates_select_authenticated" ON storage.objects
    FOR SELECT
    TO authenticated
    USING (
        bucket_id = 'templates' AND
        auth.validate_user_authentication()
    );

CREATE POLICY "templates_admin_only_modify" ON storage.objects
    FOR ALL
    TO authenticated
    USING (
        bucket_id = 'templates' AND
        auth.can_perform_admin_action('system_configuration'::admin_action_category)
    );

-- System bucket policies (super admin only)
CREATE POLICY "system_super_admin_only" ON storage.objects
    FOR ALL
    TO authenticated
    USING (
        bucket_id = 'system' AND
        auth.get_admin_permission_level() = 'super_admin'
    );

-- =====================================================
-- FILE ACCESS AUDIT TRIGGERS
-- =====================================================

-- Create audit trigger for storage access
CREATE OR REPLACE FUNCTION audit_storage_access()
RETURNS TRIGGER AS $$
BEGIN
    -- Log storage operations
    CASE TG_OP
        WHEN 'INSERT' THEN
            PERFORM auth.log_file_access(NEW.name, 'write', true);
            RETURN NEW;
        WHEN 'UPDATE' THEN
            PERFORM auth.log_file_access(NEW.name, 'update', true);
            RETURN NEW;
        WHEN 'DELETE' THEN
            PERFORM auth.log_file_access(OLD.name, 'delete', true);
            RETURN OLD;
        ELSE
            RETURN COALESCE(NEW, OLD);
    END CASE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply audit trigger to storage.objects (if accessible)
-- Note: This may need to be applied at the Supabase dashboard level
-- CREATE TRIGGER audit_storage_objects_trigger
--     AFTER INSERT OR UPDATE OR DELETE ON storage.objects
--     FOR EACH ROW
--     EXECUTE FUNCTION audit_storage_access();

-- =====================================================
-- ARTIFACT SECURITY FUNCTIONS
-- =====================================================

-- Function to create secure artifact record with file
CREATE OR REPLACE FUNCTION auth.create_secure_artifact(
    workflow_uuid UUID,
    artifact_name TEXT,
    artifact_description TEXT,
    artifact_type_val artifact_type,
    file_path_val TEXT,
    file_size_val BIGINT,
    mime_type_val TEXT,
    content_hash_val TEXT DEFAULT NULL,
    is_public_val BOOLEAN DEFAULT false
) RETURNS UUID AS $$
DECLARE
    user_uuid UUID;
    artifact_id UUID;
BEGIN
    user_uuid := auth.user_id();
    
    -- Validate authentication
    IF NOT auth.validate_user_authentication() THEN
        RAISE EXCEPTION 'User authentication validation failed';
    END IF;
    
    -- Validate workflow access
    IF NOT auth.can_access_workflow(workflow_uuid) THEN
        RAISE EXCEPTION 'User cannot access specified workflow';
    END IF;
    
    -- Validate file access
    IF NOT auth.can_access_file(file_path_val) THEN
        RAISE EXCEPTION 'User cannot access specified file path';
    END IF;
    
    -- Create artifact record
    INSERT INTO public.artifacts (
        workflow_id,
        user_id,
        name,
        description,
        artifact_type,
        file_path,
        file_size,
        mime_type,
        content_hash,
        is_public,
        processing_status
    ) VALUES (
        workflow_uuid,
        user_uuid,
        artifact_name,
        artifact_description,
        artifact_type_val,
        file_path_val,
        file_size_val,
        mime_type_val,
        content_hash_val,
        is_public_val,
        'completed'
    ) RETURNING id INTO artifact_id;
    
    -- Log artifact creation
    PERFORM auth.log_security_event(
        'artifact_created',
        user_uuid,
        NULL,
        NULL,
        NULL,
        true,
        NULL,
        jsonb_build_object(
            'artifact_id', artifact_id,
            'workflow_id', workflow_uuid,
            'file_path', file_path_val,
            'file_size', file_size_val,
            'is_public', is_public_val
        )
    );
    
    RETURN artifact_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to generate secure file access URL
CREATE OR REPLACE FUNCTION auth.generate_secure_file_url(
    file_path TEXT,
    expires_in INTERVAL DEFAULT '1 hour'
) RETURNS TEXT AS $$
DECLARE
    user_uuid UUID;
    access_token TEXT;
    expires_at TIMESTAMPTZ;
BEGIN
    user_uuid := auth.user_id();
    
    -- Validate authentication and file access
    IF NOT auth.validate_user_authentication() THEN
        RETURN NULL;
    END IF;
    
    IF NOT auth.can_access_file(file_path) THEN
        -- Log unauthorized access attempt
        PERFORM auth.log_file_access(file_path, 'read', false, 'Unauthorized access attempt');
        RETURN NULL;
    END IF;
    
    -- Generate secure access token (simplified - in practice would use JWT)
    access_token := encode(
        hmac(
            user_uuid::TEXT || '::' || file_path || '::' || (NOW() + expires_in)::TEXT,
            'secure_file_access_key', -- Should be from environment
            'sha256'
        ),
        'base64'
    );
    
    expires_at := NOW() + expires_in;
    
    -- Log file access
    PERFORM auth.log_file_access(file_path, 'read', true);
    
    -- Return secure URL (would integrate with Supabase Storage signed URLs)
    RETURN '/storage/v1/object/sign/' || file_path || '?token=' || access_token || '&expires=' || extract(epoch from expires_at);
EXCEPTION
    WHEN OTHERS THEN
        PERFORM auth.log_file_access(file_path, 'read', false, SQLERRM);
        RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- STORAGE MONITORING VIEWS
-- =====================================================

-- View for storage usage by user
CREATE OR REPLACE VIEW auth.user_storage_usage AS
SELECT 
    u.email,
    COUNT(a.id) as total_artifacts,
    COALESCE(SUM(a.file_size), 0) as total_storage_bytes,
    pg_size_pretty(COALESCE(SUM(a.file_size), 0)) as total_storage_formatted,
    COUNT(*) FILTER (WHERE a.is_public = true) as public_artifacts,
    COUNT(*) FILTER (WHERE a.artifact_type = 'user_upload') as user_uploads,
    MAX(a.created_at) as last_upload
FROM public.users u
LEFT JOIN public.artifacts a ON u.id = a.user_id AND a.status != 'deleted'
GROUP BY u.id, u.email
ORDER BY total_storage_bytes DESC;

-- View for storage security events
CREATE OR REPLACE VIEW auth.storage_security_events AS
SELECT 
    sal.id,
    u.email,
    sal.created_at,
    sal.action_type,
    sal.success,
    sal.metadata->>'file_path' as file_path,
    sal.metadata->>'access_type' as access_type,
    sal.metadata->>'bucket' as bucket,
    sal.error_message,
    sal.ip_address
FROM public.security_audit_log sal
LEFT JOIN public.users u ON sal.user_id = u.id
WHERE sal.action_type = 'file_access'
AND sal.created_at > NOW() - INTERVAL '7 days'
ORDER BY sal.created_at DESC;

-- =====================================================
-- COMMENTS AND DOCUMENTATION
-- =====================================================

COMMENT ON FUNCTION auth.validate_user_authentication() IS 'Comprehensive user authentication validation';
COMMENT ON FUNCTION auth.can_access_file(TEXT) IS 'Checks if user can access specific file path';
COMMENT ON FUNCTION auth.can_upload_file() IS 'Validates file upload permissions with size and type limits';
COMMENT ON FUNCTION auth.log_file_access() IS 'Logs file access attempts for audit trail';
COMMENT ON FUNCTION auth.create_secure_artifact() IS 'Creates artifact record with security validations';
COMMENT ON FUNCTION auth.generate_secure_file_url(TEXT, INTERVAL) IS 'Generates secure file access URL with expiration';

COMMENT ON VIEW auth.user_storage_usage IS 'Storage usage statistics by user';
COMMENT ON VIEW auth.storage_security_events IS 'Recent storage security events and access attempts';