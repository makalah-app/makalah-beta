-- Migration: Task 09 - API Utilities and Interface Functions
-- Description: Comprehensive API functions untuk artifact storage dan versioning
-- Author: Database Architect - Task 09 Implementation  
-- Date: 2025-01-26

-- =====================================================
-- ARTIFACT MANAGEMENT API FUNCTIONS
-- =====================================================

-- Function to create new artifact dengan comprehensive validation
CREATE OR REPLACE FUNCTION api_create_artifact(
    workflow_uuid UUID,
    artifact_name TEXT,
    artifact_description TEXT DEFAULT NULL,
    artifact_type_val artifact_type,
    file_content BYTEA DEFAULT NULL,
    file_extension TEXT DEFAULT '.txt',
    mime_type_val TEXT DEFAULT 'text/plain',
    is_public_val BOOLEAN DEFAULT false,
    tags_val TEXT[] DEFAULT NULL,
    metadata_val JSONB DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    user_uuid UUID;
    artifact_id UUID;
    file_path_generated TEXT;
    content_hash_val VARCHAR(64);
    phase_name TEXT;
    result JSONB;
BEGIN
    user_uuid := auth.user_id();
    
    -- Validate authentication
    IF NOT auth.validate_user_authentication() THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Authentication required'
        );
    END IF;
    
    -- Validate workflow access
    IF NOT auth.can_access_workflow(workflow_uuid) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Insufficient permissions untuk workflow'
        );
    END IF;
    
    -- Get current phase name for path generation
    SELECT wp.name INTO phase_name
    FROM public.workflow_phases wp
    JOIN public.workflows w ON w.current_phase_id = wp.id
    WHERE w.id = workflow_uuid;
    
    -- Generate structured file path
    file_path_generated := generate_artifact_file_path(
        user_uuid,
        workflow_uuid,
        phase_name,
        artifact_name,
        artifact_type_val,
        1, -- initial version
        file_extension
    );
    
    -- Calculate content hash if content provided
    IF file_content IS NOT NULL THEN
        content_hash_val := encode(sha256(file_content), 'hex');
    END IF;
    
    -- Check storage quota
    IF NOT check_storage_quota(user_uuid, 'artifacts', COALESCE(octet_length(file_content), 0)) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Storage quota exceeded'
        );
    END IF;
    
    -- Create artifact record
    INSERT INTO public.artifacts (
        workflow_id,
        user_id,
        name,
        description,
        artifact_type,
        file_path,
        file_size,
        mime_type,
        content_hash,
        is_public,
        tags,
        structured_content,
        processing_status
    ) VALUES (
        workflow_uuid,
        user_uuid,
        artifact_name,
        artifact_description,
        artifact_type_val,
        file_path_generated,
        COALESCE(octet_length(file_content), 0),
        mime_type_val,
        content_hash_val,
        is_public_val,
        COALESCE(tags_val, ARRAY[]::TEXT[]),
        COALESCE(metadata_val, '{}'::jsonb),
        'pending'
    ) RETURNING id INTO artifact_id;
    
    -- Enqueue storage sync if file content provided
    IF file_content IS NOT NULL THEN
        PERFORM enqueue_storage_sync(
            artifact_id,
            'upload'::sync_operation,
            file_path_generated,
            NULL,
            5, -- standard priority
            jsonb_build_object(
                'mime_type', mime_type_val,
                'content_size', octet_length(file_content)
            )
        );
    END IF;
    
    -- Update user storage quota
    PERFORM calculate_user_storage_quota(user_uuid, 'artifacts');
    
    result := jsonb_build_object(
        'success', true,
        'artifact_id', artifact_id,
        'file_path', file_path_generated,
        'content_hash', content_hash_val,
        'processing_status', 'pending',
        'created_at', NOW()
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get artifact dengan comprehensive details
CREATE OR REPLACE FUNCTION api_get_artifact(
    artifact_uuid UUID,
    include_versions BOOLEAN DEFAULT false,
    include_metadata BOOLEAN DEFAULT true
)
RETURNS JSONB AS $$
DECLARE
    user_uuid UUID;
    artifact_record RECORD;
    versions_data JSONB := '[]'::jsonb;
    metadata_data JSONB := '{}'::jsonb;
    result JSONB;
BEGIN
    user_uuid := auth.user_id();
    
    -- Get artifact details dengan access validation
    SELECT 
        a.*,
        w.name as workflow_name,
        u.email as owner_email
    INTO artifact_record
    FROM public.artifacts a
    JOIN public.workflows w ON w.id = a.workflow_id
    JOIN public.users u ON u.id = a.user_id
    WHERE a.id = artifact_uuid
    AND (
        a.user_id = user_uuid OR
        a.is_public = true OR
        auth.can_access_workflow(a.workflow_id) OR
        auth.can_perform_admin_action('artifact_management'::admin_action_category)
    );
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Artifact not found or access denied'
        );
    END IF;
    
    -- Get versions if requested
    IF include_versions THEN
        SELECT jsonb_agg(
            jsonb_build_object(
                'version_number', av.version_number,
                'version_name', av.version_name,
                'action', av.action,
                'file_size', av.file_size,
                'change_summary', av.change_summary,
                'is_major_version', av.is_major_version,
                'created_at', av.created_at,
                'created_by', av.created_by
            )
            ORDER BY av.version_number DESC
        ) INTO versions_data
        FROM public.artifact_versions av
        WHERE av.artifact_id = artifact_uuid;
    END IF;
    
    -- Get metadata if requested
    IF include_metadata THEN
        SELECT jsonb_object_agg(
            am.category || '.' || am.metadata_key,
            am.metadata_value
        ) INTO metadata_data
        FROM public.artifact_metadata am
        WHERE am.artifact_id = artifact_uuid
        AND (am.is_public = true OR artifact_record.user_id = user_uuid);
    END IF;
    
    -- Build result
    result := jsonb_build_object(
        'success', true,
        'artifact', jsonb_build_object(
            'id', artifact_record.id,
            'name', artifact_record.name,
            'description', artifact_record.description,
            'artifact_type', artifact_record.artifact_type,
            'status', artifact_record.status,
            'current_version', artifact_record.current_version,
            'total_versions', artifact_record.total_versions,
            'file_path', artifact_record.file_path,
            'file_size', artifact_record.file_size,
            'mime_type', artifact_record.mime_type,
            'content_hash', artifact_record.content_hash,
            'is_public', artifact_record.is_public,
            'tags', artifact_record.tags,
            'download_count', artifact_record.download_count,
            'last_accessed_at', artifact_record.last_accessed_at,
            'quality_score', artifact_record.quality_score,
            'processing_status', artifact_record.processing_status,
            'workflow_name', artifact_record.workflow_name,
            'owner_email', artifact_record.owner_email,
            'created_at', artifact_record.created_at,
            'updated_at', artifact_record.updated_at
        ),
        'versions', COALESCE(versions_data, '[]'::jsonb),
        'metadata', COALESCE(metadata_data, '{}'::jsonb)
    );
    
    -- Update access tracking
    UPDATE public.artifacts
    SET last_accessed_at = NOW(),
        download_count = download_count + 1
    WHERE id = artifact_uuid;
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to update artifact dengan versioning
CREATE OR REPLACE FUNCTION api_update_artifact(
    artifact_uuid UUID,
    updates JSONB,
    create_version BOOLEAN DEFAULT true,
    version_type TEXT DEFAULT 'patch'
)
RETURNS JSONB AS $$
DECLARE
    user_uuid UUID;
    artifact_record RECORD;
    new_version_id UUID;
    updated_fields TEXT[] := '{}';
    result JSONB;
BEGIN
    user_uuid := auth.user_id();
    
    -- Get current artifact
    SELECT * INTO artifact_record
    FROM public.artifacts
    WHERE id = artifact_uuid
    AND (
        user_id = user_uuid OR
        auth.can_access_workflow(workflow_id) OR
        auth.can_perform_admin_action('artifact_management'::admin_action_category)
    );
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Artifact not found or insufficient permissions'
        );
    END IF;
    
    -- Process updates
    IF updates ? 'name' AND updates->>'name' != artifact_record.name THEN
        UPDATE public.artifacts SET name = updates->>'name' WHERE id = artifact_uuid;
        updated_fields := array_append(updated_fields, 'name');
    END IF;
    
    IF updates ? 'description' THEN
        UPDATE public.artifacts SET description = updates->>'description' WHERE id = artifact_uuid;
        updated_fields := array_append(updated_fields, 'description');
    END IF;
    
    IF updates ? 'tags' THEN
        UPDATE public.artifacts 
        SET tags = ARRAY(SELECT jsonb_array_elements_text(updates->'tags'))
        WHERE id = artifact_uuid;
        updated_fields := array_append(updated_fields, 'tags');
    END IF;
    
    IF updates ? 'is_public' THEN
        UPDATE public.artifacts SET is_public = (updates->>'is_public')::BOOLEAN WHERE id = artifact_uuid;
        updated_fields := array_append(updated_fields, 'is_public');
    END IF;
    
    IF updates ? 'structured_content' THEN
        UPDATE public.artifacts SET structured_content = updates->'structured_content' WHERE id = artifact_uuid;
        updated_fields := array_append(updated_fields, 'structured_content');
    END IF;
    
    -- Create version if requested dan there were meaningful changes
    IF create_version AND array_length(updated_fields, 1) > 0 THEN
        new_version_id := create_semantic_artifact_version(
            artifact_uuid,
            NULL, -- auto-generate version name
            version_type,
            'Updated: ' || array_to_string(updated_fields, ', '),
            updates->'structured_content',
            user_uuid
        );
    END IF;
    
    result := jsonb_build_object(
        'success', true,
        'artifact_id', artifact_uuid,
        'updated_fields', updated_fields,
        'new_version_id', new_version_id,
        'updated_at', NOW()
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- BATCH OPERATIONS API FUNCTIONS
-- =====================================================

-- Function untuk batch artifact creation
CREATE OR REPLACE FUNCTION api_create_artifacts_batch(
    workflow_uuid UUID,
    artifacts_data JSONB
)
RETURNS JSONB AS $$
DECLARE
    user_uuid UUID;
    artifact_item JSONB;
    created_artifacts JSONB[] := '{}';
    failed_artifacts JSONB[] := '{}';
    artifact_result JSONB;
    success_count INTEGER := 0;
    total_count INTEGER := 0;
BEGIN
    user_uuid := auth.user_id();
    total_count := jsonb_array_length(artifacts_data);
    
    -- Validate authentication dan workflow access
    IF NOT auth.validate_user_authentication() THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Authentication required'
        );
    END IF;
    
    IF NOT auth.can_access_workflow(workflow_uuid) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Insufficient workflow permissions'
        );
    END IF;
    
    -- Process each artifact
    FOR artifact_item IN SELECT jsonb_array_elements(artifacts_data) LOOP
        artifact_result := api_create_artifact(
            workflow_uuid,
            artifact_item->>'name',
            artifact_item->>'description',
            (artifact_item->>'artifact_type')::artifact_type,
            NULL, -- file content handled separately
            COALESCE(artifact_item->>'file_extension', '.txt'),
            COALESCE(artifact_item->>'mime_type', 'text/plain'),
            COALESCE((artifact_item->>'is_public')::BOOLEAN, false),
            CASE 
                WHEN artifact_item ? 'tags' THEN 
                    ARRAY(SELECT jsonb_array_elements_text(artifact_item->'tags'))
                ELSE NULL 
            END,
            artifact_item->'metadata'
        );
        
        IF artifact_result->>'success' = 'true' THEN
            created_artifacts := array_append(created_artifacts, artifact_result);
            success_count := success_count + 1;
        ELSE
            failed_artifacts := array_append(failed_artifacts, jsonb_build_object(
                'artifact_data', artifact_item,
                'error', artifact_result->>'error'
            ));
        END IF;
    END LOOP;
    
    RETURN jsonb_build_object(
        'success', true,
        'total_processed', total_count,
        'successful_creates', success_count,
        'failed_creates', total_count - success_count,
        'created_artifacts', array_to_json(created_artifacts),
        'failed_artifacts', array_to_json(failed_artifacts),
        'processed_at', NOW()
    );
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- SEARCH AND FILTERING API FUNCTIONS
-- =====================================================

-- Function untuk advanced artifact search
CREATE OR REPLACE FUNCTION api_search_artifacts(
    search_params JSONB
)
RETURNS JSONB AS $$
DECLARE
    user_uuid UUID;
    base_query TEXT;
    where_conditions TEXT[] := '{}';
    order_clause TEXT := 'ORDER BY a.updated_at DESC';
    limit_clause TEXT := 'LIMIT 20';
    search_results JSONB;
    total_count INTEGER;
BEGIN
    user_uuid := auth.user_id();
    
    base_query := '
        SELECT 
            a.id,
            a.name,
            a.artifact_type,
            a.status,
            a.current_version,
            a.file_size,
            a.is_public,
            a.tags,
            a.quality_score,
            a.created_at,
            a.updated_at,
            w.name as workflow_name,
            u.email as owner_email
        FROM public.artifacts a
        JOIN public.workflows w ON w.id = a.workflow_id
        JOIN public.users u ON u.id = a.user_id
    ';
    
    -- Add access control condition
    where_conditions := array_append(where_conditions, 
        '(a.user_id = ''' || user_uuid || ''' OR a.is_public = true OR auth.can_access_workflow(a.workflow_id))'
    );
    
    -- Add search filters
    IF search_params ? 'query' THEN
        where_conditions := array_append(where_conditions,
            'to_tsvector(''simple'', coalesce(a.name, '''') || '' '' || coalesce(a.description, '''')) @@ plainto_tsquery(''simple'', ''' || 
            replace(search_params->>'query', '''', '''''') || ''')'
        );
    END IF;
    
    IF search_params ? 'workflow_id' THEN
        where_conditions := array_append(where_conditions,
            'a.workflow_id = ''' || (search_params->>'workflow_id') || ''''
        );
    END IF;
    
    IF search_params ? 'artifact_type' THEN
        where_conditions := array_append(where_conditions,
            'a.artifact_type = ''' || (search_params->>'artifact_type') || ''''
        );
    END IF;
    
    IF search_params ? 'status' THEN
        where_conditions := array_append(where_conditions,
            'a.status = ''' || (search_params->>'status') || ''''
        );
    END IF;
    
    IF search_params ? 'is_public' THEN
        where_conditions := array_append(where_conditions,
            'a.is_public = ' || (search_params->>'is_public')::BOOLEAN
        );
    END IF;
    
    IF search_params ? 'tags' THEN
        where_conditions := array_append(where_conditions,
            'a.tags && ARRAY[' || 
            (SELECT string_agg('''''' || tag || '''', ', ') 
             FROM jsonb_array_elements_text(search_params->'tags') AS tag) || 
            ']'
        );
    END IF;
    
    IF search_params ? 'date_from' THEN
        where_conditions := array_append(where_conditions,
            'a.created_at >= ''' || (search_params->>'date_from') || ''''
        );
    END IF;
    
    IF search_params ? 'date_to' THEN
        where_conditions := array_append(where_conditions,
            'a.created_at <= ''' || (search_params->>'date_to') || ''''
        );
    END IF;
    
    -- Add ordering
    IF search_params ? 'sort_by' THEN
        CASE search_params->>'sort_by'
            WHEN 'name' THEN order_clause := 'ORDER BY a.name ' || COALESCE(search_params->>'sort_direction', 'ASC');
            WHEN 'created_at' THEN order_clause := 'ORDER BY a.created_at ' || COALESCE(search_params->>'sort_direction', 'DESC');
            WHEN 'updated_at' THEN order_clause := 'ORDER BY a.updated_at ' || COALESCE(search_params->>'sort_direction', 'DESC');
            WHEN 'file_size' THEN order_clause := 'ORDER BY a.file_size ' || COALESCE(search_params->>'sort_direction', 'DESC');
            WHEN 'quality_score' THEN order_clause := 'ORDER BY a.quality_score ' || COALESCE(search_params->>'sort_direction', 'DESC');
            ELSE order_clause := 'ORDER BY a.updated_at DESC';
        END CASE;
    END IF;
    
    -- Add limit dan offset
    IF search_params ? 'limit' THEN
        limit_clause := 'LIMIT ' || (search_params->>'limit')::INTEGER;
    END IF;
    
    IF search_params ? 'offset' THEN
        limit_clause := limit_clause || ' OFFSET ' || (search_params->>'offset')::INTEGER;
    END IF;
    
    -- Execute search query
    EXECUTE 'SELECT jsonb_agg(row_to_json(search_data)) FROM (' ||
            base_query ||
            CASE WHEN array_length(where_conditions, 1) > 0 
                THEN ' WHERE ' || array_to_string(where_conditions, ' AND ')
                ELSE ''
            END ||
            ' ' || order_clause ||
            ' ' || limit_clause ||
            ') search_data'
    INTO search_results;
    
    -- Get total count
    EXECUTE 'SELECT COUNT(*) FROM (' ||
            base_query ||
            CASE WHEN array_length(where_conditions, 1) > 0 
                THEN ' WHERE ' || array_to_string(where_conditions, ' AND ')
                ELSE ''
            END ||
            ') count_data'
    INTO total_count;
    
    RETURN jsonb_build_object(
        'success', true,
        'total_count', total_count,
        'results', COALESCE(search_results, '[]'::jsonb),
        'search_params', search_params,
        'searched_at', NOW()
    );
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- UTILITY API FUNCTIONS
-- =====================================================

-- Function to get user dashboard data
CREATE OR REPLACE FUNCTION api_get_user_dashboard(user_uuid_param UUID DEFAULT NULL)
RETURNS JSONB AS $$
DECLARE
    target_user_uuid UUID;
    dashboard_data JSONB;
    artifact_stats JSONB;
    quota_status JSONB;
    recent_artifacts JSONB;
    version_activity JSONB;
BEGIN
    target_user_uuid := COALESCE(user_uuid_param, auth.user_id());
    
    -- Validate access (user can only see own dashboard unless admin)
    IF target_user_uuid != auth.user_id() AND 
       NOT auth.can_perform_admin_action('user_management'::admin_action_category) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Access denied'
        );
    END IF;
    
    -- Get artifact statistics
    SELECT jsonb_build_object(
        'total_artifacts', COUNT(*),
        'public_artifacts', COUNT(*) FILTER (WHERE is_public = true),
        'draft_artifacts', COUNT(*) FILTER (WHERE status = 'draft'),
        'active_artifacts', COUNT(*) FILTER (WHERE status = 'active'),
        'total_file_size', COALESCE(SUM(file_size), 0),
        'avg_quality_score', ROUND(AVG(quality_score), 2)
    ) INTO artifact_stats
    FROM public.artifacts
    WHERE user_id = target_user_uuid;
    
    -- Get quota status
    SELECT jsonb_agg(
        jsonb_build_object(
            'bucket_name', bucket_name,
            'current_usage', current_usage,
            'quota_limit', quota_limit,
            'usage_percentage', usage_percentage,
            'quota_exceeded', quota_exceeded
        )
    ) INTO quota_status
    FROM get_user_quota_status(target_user_uuid);
    
    -- Get recent artifacts
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', id,
            'name', name,
            'artifact_type', artifact_type,
            'current_version', current_version,
            'updated_at', updated_at
        )
        ORDER BY updated_at DESC
    ) INTO recent_artifacts
    FROM (
        SELECT id, name, artifact_type, current_version, updated_at
        FROM public.artifacts
        WHERE user_id = target_user_uuid
        AND status = 'active'
        ORDER BY updated_at DESC
        LIMIT 10
    ) recent;
    
    -- Get version activity
    SELECT jsonb_agg(
        jsonb_build_object(
            'artifact_name', a.name,
            'version_number', av.version_number,
            'action', av.action,
            'created_at', av.created_at
        )
        ORDER BY av.created_at DESC
    ) INTO version_activity
    FROM public.artifact_versions av
    JOIN public.artifacts a ON a.id = av.artifact_id
    WHERE a.user_id = target_user_uuid
    AND av.created_at >= NOW() - INTERVAL '7 days'
    ORDER BY av.created_at DESC
    LIMIT 20;
    
    dashboard_data := jsonb_build_object(
        'success', true,
        'user_id', target_user_uuid,
        'artifact_statistics', artifact_stats,
        'quota_status', COALESCE(quota_status, '[]'::jsonb),
        'recent_artifacts', COALESCE(recent_artifacts, '[]'::jsonb),
        'version_activity', COALESCE(version_activity, '[]'::jsonb),
        'generated_at', NOW()
    );
    
    RETURN dashboard_data;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- COMMENTS AND DOCUMENTATION
-- =====================================================

COMMENT ON FUNCTION api_create_artifact() IS 'Comprehensive artifact creation dengan validation dan storage sync';
COMMENT ON FUNCTION api_get_artifact() IS 'Retrieves artifact dengan versions dan metadata';
COMMENT ON FUNCTION api_update_artifact() IS 'Updates artifact dengan automatic versioning';
COMMENT ON FUNCTION api_create_artifacts_batch() IS 'Batch artifact creation dengan error handling';
COMMENT ON FUNCTION api_search_artifacts() IS 'Advanced artifact search dengan multiple filters';
COMMENT ON FUNCTION api_get_user_dashboard() IS 'User dashboard data dengan statistics dan recent activity';