/**
 * CHAT API ROUTE - DUAL PROVIDER IMPLEMENTATION
 * 
 * AI SDK v5 compliant streaming dengan Gemini 2.5 Pro primary (OpenRouter)
 * dan OpenAI GPT-4o-mini fallback. Enhanced academic workflow support.
 */

import { 
  streamText, 
  UIMessage, 
  convertToModelMessages, 
  stepCountIs, 
  tool, 
  isToolUIPart, 
  getToolName,
  createUIMessageStreamResponse,
  createUIMessageStream
} from 'ai';
import { openai } from '@ai-sdk/openai';
import { SearchProviderManager } from '../../../src/lib/ai/tools/search/search-providers';
import { z } from 'zod';
import type { AcademicMetadata } from '../../../src/components/chat/ChatContainer';
import { getDynamicModelConfig, getDynamicPrimaryModel, getDynamicFallbackModel } from '../../../src/lib/ai/dynamic-config';
// AI SDK v5 compliant tool imports
import {
  phaseCompletionTools,
  getConversationAwareTools,
  getConversationSummary
} from '../../../src/lib/ai/tools/academic-tools';
import { CompletionSignalUtils } from '../../../src/lib/ai/workflow/completion-signals';
import { processToolResultsForApproval } from '../../../src/lib/ai/workflow/hitl-integration';
// import { ArtifactTrigger } from '../../../src/lib/ai/workflow/artifact-trigger';
import { fileTools } from '../../../src/lib/ai/tools/file-tools';
import { citationTools } from '../../../src/lib/ai/tools/citation-analysis-tools';
import { getUserIdWithSystemFallback } from '../../../src/lib/database/supabase-server-auth';
import { PhaseDetector } from '../../../src/lib/ai/workflow/phase-detector';
import { getValidUserUUID } from '../../../src/lib/utils/uuid-generator';
// P0.1 Natural Language Approval - Import validation helpers
import { detectApprovalIntent, extractTextFromMessage, isResponseToApprovalOffer } from '../../../src/lib/ai/workflow/hitl-utils';
// P0.1 Audit Trail System - Import approval recording functions
import { recordApproval, getRecentApprovals, isDuplicateApproval, type ApprovalLedger } from '../../../src/lib/database/message-validation';

// Allow streaming responses up to 30 seconds
export const maxDuration = 30;

// Define custom message type with academic metadata
export type AcademicUIMessage = UIMessage<AcademicMetadata>;

// AI SDK v5 compliant tools imported from academic-tools.ts
// Tools are properly defined with Zod schemas and follow HITL patterns

/**
 * P0.1 Natural Language Approval - Server-side validation system
 * Validates user approval intent before tool execution
 */

/**
 * Approval context interface for tracking offers and responses
 */
interface ApprovalContext {
  offerId: string;
  offerMessageId: string;
  offerTimestamp: number;
  phase: number;
  userReplyId?: string;
  userIntent?: 'approve' | 'revise' | 'unclear';
  validated: boolean;
}

/**
 * In-memory tracking of recent approval offers
 * TODO: Move to Redis/database for production persistence
 */
const recentApprovalOffers = new Map<string, ApprovalContext>();

/**
 * Validate recent approval for tool execution
 * Core validation function - prevents tool execution without proper approval
 */
async function validateRecentApproval(
  messages: AcademicUIMessage[],
  toolName: string,
  userId: string
): Promise<{ valid: boolean; intent?: any; reasoning: string }> {
  console.log(`[NaturalApproval] Validating approval for tool: ${toolName}`);

  // Extract phase number from tool name
  const phaseMatch = toolName.match(/complete_phase_(\d+)/);
  if (!phaseMatch) {
    return { valid: false, reasoning: 'Invalid tool name format' };
  }
  const phase = parseInt(phaseMatch[1]);

  // Need at least 2 messages (assistant offer + user response)
  if (messages.length < 2) {
    return { valid: false, reasoning: 'Insufficient message history' };
  }

  // Get last user message (should be approval response)
  const lastUserMessage = messages.slice(-5).reverse().find(m => m.role === 'user');
  if (!lastUserMessage) {
    return { valid: false, reasoning: 'No recent user message found' };
  }

  // Get recent assistant messages (should contain approval offer)
  const recentAssistantMessages = messages.slice(-5)
    .filter(m => m.role === 'assistant')
    .map(m => extractTextFromMessage(m));

  const userText = extractTextFromMessage(lastUserMessage);
  console.log(`[NaturalApproval] User message: "${userText}"`);

  // Check if this is a response to approval offer
  if (!isResponseToApprovalOffer(userText, recentAssistantMessages)) {
    console.log('[NaturalApproval] User message is not responding to approval offer');
    return { valid: false, reasoning: 'User message not responding to approval offer' };
  }

  // Detect intent from user message
  const intent = detectApprovalIntent(userText);
  console.log(`[NaturalApproval] Intent detection:`, intent);

  // Require clear approval intent with high confidence
  if (intent.intent !== 'approve' || intent.confidence < 0.7) {
    if (intent.intent === 'unclear') {
      return {
        valid: false,
        intent,
        reasoning: `Unclear intent detected - asking for clarification`
      };
    } else if (intent.intent === 'revise') {
      return {
        valid: false,
        intent,
        reasoning: `Revision requested: ${intent.feedback || 'No specific feedback'}`
      };
    } else {
      return {
        valid: false,
        intent,
        reasoning: `Approval confidence too low: ${intent.confidence}`
      };
    }
  }

  // Check timing - offer should be recent (within last 3 messages from assistant)
  const hasRecentOffer = recentAssistantMessages.some(msg =>
    /konfirmasi:.*setuju.*hasil.*fase\s*\d+/i.test(msg)
  );

  if (!hasRecentOffer) {
    return {
      valid: false,
      reasoning: 'No recent approval offer found in assistant messages'
    };
  }

  // üîç P0.1 AUDIT: Check for duplicate approvals to prevent double-processing
  const conversationId = lastUserMessage.metadata?.conversationId ||
                         lastUserMessage.metadata?.workflowId ||
                         `session-${userId}`;

  try {
    const recentApprovals = await getRecentApprovals(conversationId);
    if (isDuplicateApproval(recentApprovals, phase)) {
      return {
        valid: false,
        reasoning: `Duplicate approval detected for phase ${phase} within time window`
      };
    }
  } catch (error) {
    console.warn(`[NaturalApproval] Could not check duplicate approvals: ${error}`);
    // Continue with validation - don't block on audit failure
  }

  // All validations passed - record the approval
  console.log(`[NaturalApproval] ‚úÖ Approval validated for phase ${phase}`);

  // üìù P0.1 AUDIT: Record approval event for compliance
  try {
    const auditLedger: ApprovalLedger = {
      conversation_id: conversationId,
      phase,
      approved: true,
      timestamp: Date.now(),
      user_id: userId,
      offer_message_id: recentAssistantMessages[0] ? `assistant-recent` : undefined,
      user_reply_message_id: lastUserMessage.id,
      metadata: {
        intent_confidence: intent.confidence,
        validation_method: 'natural_language',
        reasoning: intent.reasoning,
        user_message: userText.substring(0, 200), // Truncate for storage
        assistant_offer: recentAssistantMessages[0]?.substring(0, 200),
      }
    };

    await recordApproval(auditLedger);
    console.log(`[NaturalApproval] üìù Approval audit recorded successfully`);

  } catch (auditError) {
    console.error(`[NaturalApproval] ‚ùå Audit recording failed:`, auditError);
    // Don't block approval on audit failure
  }

  return {
    valid: true,
    intent,
    reasoning: `Valid approval for phase ${phase} with confidence ${intent.confidence}`
  };
}

/**
 * Handle unclear approval intent - request clarification
 * P0.1 Audit: Also records the unclear event
 */
async function handleUnclearIntent(
  intent: any,
  phase: number,
  userId: string,
  conversationId: string,
  userMessage: string
): Promise<string> {
  // üìù P0.1 AUDIT: Record unclear intent event
  try {
    const auditLedger: ApprovalLedger = {
      conversation_id: conversationId,
      phase,
      approved: false,
      timestamp: Date.now(),
      user_id: userId,
      metadata: {
        intent_confidence: intent.confidence,
        validation_method: 'natural_language',
        reasoning: intent.reasoning,
        user_message: userMessage.substring(0, 200),
      }
    };

    await recordApproval(auditLedger);
    console.log(`[NaturalApproval] üìù Unclear intent audit recorded for phase ${phase}`);

  } catch (auditError) {
    console.error(`[NaturalApproval] ‚ùå Unclear intent audit failed:`, auditError);
  }

  return `ü§î Maaf, saya perlu klarifikasi untuk fase ${phase}.

${intent.reasoning}

**Apakah Anda menyetujui hasil fase ${phase}?**
Silakan jawab dengan jelas:
‚Ä¢ **"Ya"** atau **"Setuju"** - untuk menerima hasil dan generate artifact
‚Ä¢ **"Tidak"** atau **"Revisi"** dengan feedback - untuk meminta perbaikan

*Atau gunakan tombol approval jika lebih nyaman.*`;
}

/**
 * Handle revision request - process feedback
 * P0.1 Audit: Also records the revision event
 */
async function handleRevisionRequest(
  intent: any,
  phase: number,
  userId: string,
  conversationId: string,
  userMessage: string
): Promise<string> {
  const feedback = intent.feedback || 'Tidak ada feedback spesifik';

  // üìù P0.1 AUDIT: Record revision request event
  try {
    const auditLedger: ApprovalLedger = {
      conversation_id: conversationId,
      phase,
      approved: false,
      feedback,
      timestamp: Date.now(),
      user_id: userId,
      metadata: {
        intent_confidence: intent.confidence,
        validation_method: 'natural_language',
        reasoning: intent.reasoning,
        user_message: userMessage.substring(0, 200),
      }
    };

    await recordApproval(auditLedger);
    console.log(`[NaturalApproval] üìù Revision request audit recorded for phase ${phase}`);

  } catch (auditError) {
    console.error(`[NaturalApproval] ‚ùå Revision request audit failed:`, auditError);
  }

  return `üîÑ **Revisi diminta untuk Fase ${phase}**

**Feedback Anda:** ${feedback}

Baik, saya akan melakukan revisi berdasarkan feedback Anda. Mari kita perbaiki hasil fase ${phase} sesuai dengan yang Anda harapkan.

Apa aspek spesifik yang ingin diperbaiki atau ditambahkan?`;
}

/**
 * Execute approved phase tools and generate artifacts
 * Handles tool execution when user approval is detected
 */
async function executeApprovedTools(
  messages: any[],
  writer: any,
  phaseCompletionTools: any
): Promise<void> {
  console.log('[Chat API] üîç Checking for approved tools to execute...');

  for (const message of messages) {
    if (!message.parts) continue;

    for (const part of message.parts) {
      // Check for tools marked for execution via metadata
      if (isToolUIPart(part) && part.metadata?.executeAfterStream === true) {
        const toolName = getToolName(part);
        console.log(`[Chat API] ‚úÖ Executing approved tool: ${toolName}`);

        try {
          // Extract phase number from tool name
          const phaseMatch = toolName.match(/complete_phase_(\d+)/);
          if (!phaseMatch) {
            console.error(`[Chat API] ‚ùå Invalid tool name format: ${toolName}`);
            continue;
          }
          const phaseNumber = parseInt(phaseMatch[1]);

          console.log(`[Chat API] üéØ Generating artifact for Phase ${phaseNumber}`);

          // Generate phase-appropriate artifact (from hitl-integration.ts pattern)
          const { generatePhaseArtifact, getPhaseTitle, getPhaseDescription } = await import('../../../src/lib/ai/workflow/hitl-integration');
          const artifactContent = await generatePhaseArtifact(phaseNumber, part.input);

          const nextPhase = Math.min(phaseNumber + 1, 7);
          const phaseAnnouncement = phaseNumber === 7
            ? `üéâ **PAPER COMPLETE!** Fase ${phaseNumber} selesai - makalah akademik Anda siap untuk submisi!`
            : `‚úÖ **Fase ${phaseNumber} selesai!** Sekarang kita lanjut ke **Fase ${nextPhase}: ${getPhaseTitle(nextPhase)}**\n\nDi fase ini, kita akan fokus pada ${getPhaseDescription(nextPhase)}.\n\nSilakan lanjutkan percakapan dengan memberikan input, pertanyaan, atau arahan untuk fase baru ini.`;

          // Stream artifact using proper format
          writer.write({
            type: 'data',
            value: {
              type: 'phase-completion',
              id: `phase-${phaseNumber}-completion`,
              phase: phaseNumber,
              nextPhase: nextPhase,
              artifact: {
                title: `Fase ${phaseNumber}: ${getPhaseTitle(phaseNumber)}`,
                content: artifactContent,
                wordCount: artifactContent.split(/\s+/).length
              },
              announcement: phaseAnnouncement,
              isComplete: phaseNumber === 7,
              timestamp: Date.now()
            }
          });

          // Stream tool completion
          writer.write({
            type: 'tool-output-available',
            toolCallId: part.toolCallId,
            output: `‚úÖ Fase ${phaseNumber} selesai! Artifact berhasil dihasilkan.`,
          });

          // Mark tool as completed and clear execution flag
          part.state = 'completed';
          part.output = artifactContent;
          if (part.metadata) {
            part.metadata.executeAfterStream = false;
            part.metadata.executedAt = Date.now();
          }

          console.log(`[Chat API] ‚úÖ Phase ${phaseNumber} artifact generated and streamed successfully`);

        } catch (toolError) {
          console.error(`[Chat API] ‚ùå Tool execution failed for ${toolName}:`, toolError);

          // Stream error back to client
          writer.write({
            type: 'tool-output-available',
            toolCallId: part.toolCallId,
            output: `Error generating artifact for ${toolName}: ${toolError.message}`,
          });
        }
      }
    }
  }
}

export async function POST(req: Request) {
  try {
    console.log('[Chat API] Initializing NATIVE OpenAI web search system...');
    
    // Native OpenAI implementation - no custom tools needed for primary provider
    console.log('[Chat API] üåê Using built-in OpenAI web search - no mock data!');
    
    // Extract chatId from headers for persistence
    const chatId = req.headers.get('X-Chat-Id') || undefined;
    console.log(`[Chat API] üìã ChatId from headers: ${chatId || 'not provided'}`);
    
    // Extract user ID from authenticated session - NO FALLBACK to 'system'
    let userId = await getUserIdWithSystemFallback();
    console.log(`[Chat API] üë§ User ID extracted: ${userId || 'null - no session'}`);
    
    if (userId) {
      console.log(`[Chat API] ‚úÖ Authenticated user session detected - messages will persist with user ID: ${userId}`);
    } else {
      console.log(`[Chat API] ‚ö†Ô∏è No authenticated session detected - will check client-provided user ID`);
    }
    
    // Parse request body with additional academic workflow parameters
    const rawPayload: any = await req.json();
    const { 
      messages, 
      phase = 1, 
      testMode = false,
      customKey,
      userId: clientUserId,
      username: clientUsername
    }: { 
      messages: AcademicUIMessage[];
      phase?: number;
      testMode?: boolean;
      customKey?: string;
      userId?: string;
      username?: string;
    } = rawPayload || {};

    // ENHANCED FALLBACK: if SSR session missing, use client-provided userId with validation
    const headerUserId = req.headers.get('X-User-Id') || undefined;
    if (!userId) {
      const candidate = clientUserId || headerUserId;
      const valid = getValidUserUUID(candidate || undefined);
      if (valid !== '00000000-0000-4000-8000-000000000000') {
        userId = valid;
        console.log(`[Chat API] üîß Using client-provided user ID: ${userId}`);
      } else {
        console.log(`[Chat API] ‚ùå No valid client-provided user ID found`);
      }
    }

    // üîí AUTHENTICATION GUARD: Require valid user ID for all operations
    // No fallback - must have either authenticated session or valid client-provided UUID
    if (!userId) {
      console.warn('[Chat API] üö´ Authentication failed: no authenticated session and no valid client user ID provided');
      return new Response(JSON.stringify({
        error: 'AUTHENTICATION_REQUIRED',
        message: 'Valid user authentication required for all chat operations',
      }), { status: 401, headers: { 'Content-Type': 'application/json' } });
    }
    
    console.log(`[Chat API] ‚úÖ Authentication successful - proceeding with user ID: ${userId}`);

    // Initialize artifact trigger untuk phase approval handling
    // const artifactTrigger = new ArtifactTrigger();
    
    // Check for phase approval using ArtifactTrigger detection
    const phaseApprovalContext = (() => {
      try {
        if (!messages?.length) return null as any;
        const last: any = messages[messages.length - 1];
        if (!last?.parts) return null as any;
        for (const part of last.parts) {
          if (isToolUIPart(part)) {
            const t = getToolName(part) as string;
            if (typeof t === 'string' && t.startsWith('complete_phase_') && part.state === 'output-available') {
              const p = parseInt(t.replace('complete_phase_', ''), 10);
              if (typeof part.output === 'string' && (
                part.output === 'PHASE_APPROVED' || 
                part.output.includes('Phase completion approved')
              )) {
                return { phase: p, approved: true, input: part.input };
              } else if (typeof part.output === 'string' && (
                part.output.startsWith('PHASE_REVISION_REQUESTED:') ||
                part.output.includes('Phase revision requested')
              )) {
                const feedback = part.output.includes('Feedback:') 
                  ? part.output.split('Feedback:')[1]?.trim().replace('Please address the concerns and resubmit.', '').trim()
                  : part.output.replace('PHASE_REVISION_REQUESTED: ', '');
                return { phase: p, approved: false, feedback, input: part.input };
              }
            }
          }
        }
        return null as any;
      } catch { return null as any; }
    })();
    
    if (phaseApprovalContext) {
      console.log(`[Chat API] üéØ Phase approval detected:`, phaseApprovalContext);
      
      if (phaseApprovalContext.approved) {
        console.log(`[Chat API] üéâ Phase ${phaseApprovalContext.phase} approved - artifact generation will be triggered in stream`);
      } else {
        console.log(`[Chat API] üîÑ Phase ${phaseApprovalContext.phase} revision requested: ${phaseApprovalContext.feedback}`);
      }
    }

    // üõë HITL FIX P1.1: Removed premature phase advancement to allow extended discussion
    // Phase transitions are now controlled by user intent, not automatic approval
    let currentPhase = phase;

    // ‚úÖ APPROVAL CONTEXT PRESERVATION: Keep approval info for artifact generation only
    // DO NOT auto-advance phase - let user control phase progression through discussion
    if (phaseApprovalContext?.approved) {
      console.log(`[Chat API] üìã APPROVAL PRESERVED: Phase ${phaseApprovalContext.phase} approved - artifact will be generated without forced phase transition`);
    } else if (phaseApprovalContext?.approved === false) {
      console.log(`[Chat API] üîÑ REVISION REQUESTED: Phase ${phaseApprovalContext.phase} - feedback: ${phaseApprovalContext.feedback}`);
    }
    
    console.log(`[Chat API] Processing ${messages.length} messages, Phase: ${currentPhase}${testMode ? ' (TEST MODE)' : ''}`);
    
    // Debug: Log first message structure untuk troubleshooting
    if (messages.length > 0) {
      console.log('[Chat API] First message structure:', {
        id: messages[0].id,
        role: messages[0].role,
        hasContent: !!messages[0].parts && messages[0].parts.length > 0,
        hasMetadata: !!messages[0].metadata
      });
    }

    // Validate and ensure messages have proper structure
    if (!Array.isArray(messages) || messages.length === 0) {
      throw new Error('Messages array is required and must not be empty');
    }

    // üîß STEP 1: Pre-validate messages for phase detection without phase override
    const preValidatedMessages = messages.map((msg, index) => {
      return {
        id: msg.id || `msg-${Date.now()}-${index}`,
        role: msg.role || 'user',
        parts: msg.parts || [{ type: 'text', text: (msg as any).content || '' }],
        metadata: {
          ...msg.metadata,
          userId: (msg as any)?.metadata?.userId || userId,
          username: clientUsername || (msg as any)?.metadata?.username,
          // Preserve existing phase metadata for progressive tracking
          phase: (msg as any)?.metadata?.phase,
          timestamp: (msg as any)?.metadata?.timestamp || Date.now()
        }
      } as AcademicUIMessage;
    });

    // üîß STEP 2: Progressive phase detection based on conversation history
    let detectionResult: any;
    try {
      // Use linear detection with database integration
      detectionResult = await PhaseDetector.detectPhaseLinear(
        preValidatedMessages,
        userId,
        chatId // Use chatId as workflowId for phase tracking
      );
    } catch (error) {
      console.warn('[Chat API] Linear phase detection failed, using fallback:', error);
      // Fallback to conversation-based detection (no jumping allowed)
      detectionResult = PhaseDetector.detectPhase(preValidatedMessages);
    }

    const inferredPhase = detectionResult.phase;

    // üîí ENHANCED LINEAR VALIDATION: Progressive phase tracking based on conversation history
    // Get the actual phase progression from conversation history, not client-provided phase
    const conversationPhases = preValidatedMessages
      .filter(msg => msg.metadata?.phase)
      .map(msg => msg.metadata.phase)
      .filter(p => typeof p === 'number' && p >= 1 && p <= 7);

    const lastValidPhase = conversationPhases.length > 0 ? Math.max(...conversationPhases) : 1;

    // Allow maximum +1 phase progression from the highest confirmed phase in conversation
    const maxAllowedProgression = Math.min(lastValidPhase + 1, 7);
    const finalPhase = Math.min(inferredPhase, maxAllowedProgression);

    // Additional safety: prevent jumping more than 1 phase from current state
    const safePhase = Math.min(finalPhase, currentPhase + 1);

    // Update current phase with strict linear progression
    currentPhase = safePhase;
    // Expose phase progress info for UI sync in stream execution (non-approval path)
    const phaseProgressInfo = {
      lastValidPhase,
      currentPhase,
      progressed: safePhase > lastValidPhase,
    } as const;
    console.log(`[Chat API] ‚úÖ PROGRESSIVE PHASE VALIDATION:`);
    console.log(`  - Last confirmed phase in conversation: ${lastValidPhase}`);
    console.log(`  - Phase detector suggestion: ${inferredPhase}`);
    console.log(`  - Max allowed progression: ${maxAllowedProgression}`);
    console.log(`  - Final phase with safety: ${currentPhase}`);

    // üîß STEP 3: Final message validation with correct phase metadata
    const validatedMessages = preValidatedMessages.map((msg, index) => {
      // Update with the correctly determined phase
      const validatedMessage: AcademicUIMessage = {
        ...msg,
        metadata: {
          ...msg.metadata,
          // Use the progressively validated phase for new metadata
          phase: msg.metadata?.phase || currentPhase,
        }
      };

      // Log validation for debugging
      if (!msg.parts) {
        console.log(`[Chat API] üõ†Ô∏è Fixed message ${index}: Added missing parts array`);
      }

      return validatedMessage;
    });

    // üßπ Normalize legacy parts (ensure each part has a type)
    const normalizedMessages = validatedMessages.map(message => ({
      ...message,
      parts: (message.parts || []).map((part: any) => {
        if (typeof part?.type === 'string') return part;
        const text = typeof part?.text === 'string' ? part.text : (typeof part === 'string' ? part : '');
        return { type: 'text', text } as any;
      })
    }));

    // üõ†Ô∏è FIX 1: Filter out tool parts that cause AI SDK conversion errors
    const messagesForModel = normalizedMessages.map(message => ({
      ...message,
      parts: (message.parts || []).filter((part: any) => {
        try {
          // Filter tool parts in input-available state (waiting for approval)
          if (isToolUIPart(part) && part.state === 'input-available') {
            return false;
          }

          // üîß FIX: Filter tool parts with execute-pending state (invalid AI SDK state)
          if (isToolUIPart(part) && part.state === 'execute-pending') {
            console.log(`[Chat API] üîß Filtering execute-pending tool (invalid state): ${getToolName(part)}`);
            return false; // Remove execute-pending tools from AI SDK processing
          }

          // üîß FIX: Filter approved tools to prevent execute-pending state
          if (isToolUIPart(part) && part.metadata?.executeAfterStream === true) {
            console.log(`[Chat API] üîß Filtering approved tool from model processing: ${getToolName(part)}`);
            return false; // Remove approved tools from AI SDK processing
          }

          return true;
        } catch {
          // If detection fails, treat as non-tool part
          return true;
        }
      })
    }));

    // Convert UI messages to model messages using AI SDK function
    // This is the CRITICAL fix - harus menggunakan convertToModelMessages
    let processedMessages;
    try {
      processedMessages = convertToModelMessages(messagesForModel);
      console.log(`[Chat API] ‚úÖ Successfully converted ${validatedMessages.length} UI messages to ${processedMessages.length} model messages (filtered ${validatedMessages.length - messagesForModel.length} approval parts)`);
    } catch (conversionError) {
      console.error('[Chat API] ‚ùå Message conversion failed:', conversionError);
      console.log('[Chat API] üîÑ Attempting fallback message recovery...');
      
      // üõ†Ô∏è FIX 4: Enhanced error recovery - create minimal valid message structure
      try {
        // Extract text from the most recent message as fallback
        const lastMessage = validatedMessages[validatedMessages.length - 1];
        const textContent = lastMessage?.parts?.find(part => part.type === 'text')?.text ||
                           (lastMessage as any)?.content ||
                           'Hello';
        
        const fallbackMessages = [{
          id: `fallback-msg-${Date.now()}`,
          role: 'user' as const,
          parts: [{ type: 'text' as const, text: textContent }]
        }] as AcademicUIMessage[];
        
        processedMessages = convertToModelMessages(fallbackMessages);
        console.log(`[Chat API] ‚úÖ Fallback recovery successful with message: "${textContent.substring(0, 50)}..."`);
      } catch (fallbackError) {
        console.error('[Chat API] ‚ùå Fallback recovery also failed:', fallbackError);
        throw new Error(`Message processing failed completely. Original: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);
      }
    }
    
    // Get dynamic configuration from database (includes current swap state)
    const dynamicConfig = await getDynamicModelConfig();
    
    // Use database system prompt AS-IS - no hardcoded additions
    const systemPrompt = dynamicConfig.systemPrompt;

    // üöÄ IMPLEMENT: createUIMessageStream pattern from AI SDK v5 documentation
    const stream = createUIMessageStream({
      execute: async ({ writer }) => {
        console.log('[Chat API] üöÄ HITL Integration: Processing tool results and handling approvals');

        // üéØ PHASE SYNC (NON-APPROVAL): Emit phase update if progressive detection advanced the phase
        try {
          if (phaseProgressInfo.progressed) {
            writer.write({
              type: 'data-phase-update',
              data: {
                currentPhase: phaseProgressInfo.lastValidPhase,
                nextPhase: phaseProgressInfo.currentPhase,
                reason: 'progressive_detection',
                timestamp: Date.now(),
              },
            });
            console.log(`[Chat API] üì£ Emitted data-phase-update: ${phaseProgressInfo.lastValidPhase} ‚Üí ${phaseProgressInfo.currentPhase}`);
          }
        } catch (emitErr) {
          console.warn('[Chat API] ‚ö†Ô∏è Failed to emit data-phase-update:', emitErr);
        }

        // üöÄ P0.1 NATURAL LANGUAGE APPROVAL: Pre-process tool calls with validation
        console.log('[Chat API] üéØ Starting natural language approval validation');

        // Check for pending tool calls that need approval validation
        let preValidatedMessages = [...validatedMessages];
        const lastMessage = preValidatedMessages[preValidatedMessages.length - 1];

        if (lastMessage?.parts) {
          const processedParts = await Promise.all(
            lastMessage.parts.map(async (part: any) => {
              // Only process tool UI parts
              if (!isToolUIPart(part)) return part;

              const toolName = getToolName(part);
              console.log(`[NaturalApproval] Checking tool: ${toolName}, state: ${part.state}`);

              // Only process phase completion tools in input-available state
              if (!toolName?.startsWith('complete_phase_') || part.state !== 'input-available') {
                return part;
              }

              // üîí VALIDATION: Check for recent approval before processing
              const validationResult = await validateRecentApproval(preValidatedMessages, toolName, userId);
              console.log(`[NaturalApproval] Validation result:`, validationResult);

              if (!validationResult.valid) {
                // Handle different validation failure scenarios
                const phase = parseInt(toolName.replace('complete_phase_', ''));
                const userText = extractTextFromMessage(preValidatedMessages.slice(-5).reverse().find(m => m.role === 'user') || {} as any);
                const conversationId = preValidatedMessages[preValidatedMessages.length - 1]?.metadata?.conversationId ||
                                       preValidatedMessages[preValidatedMessages.length - 1]?.metadata?.workflowId ||
                                       `session-${userId}`;

                if (validationResult.intent?.intent === 'unclear') {
                  // Request clarification - don't process tool
                  console.log(`[NaturalApproval] ü§î Unclear intent for ${toolName} - requesting clarification`);

                  // Write clarification message immediately with audit logging
                  const clarificationMessage = await handleUnclearIntent(
                    validationResult.intent,
                    phase,
                    userId,
                    conversationId,
                    userText
                  );

                  writer.write({
                    type: 'text-delta',
                    textDelta: clarificationMessage,
                  });

                  return part; // Keep tool in input-available state

                } else if (validationResult.intent?.intent === 'revise') {
                  // Handle revision request - don't process tool
                  console.log(`[NaturalApproval] üîÑ Revision requested for ${toolName}`);

                  // Write revision handling message immediately with audit logging
                  const revisionMessage = await handleRevisionRequest(
                    validationResult.intent,
                    phase,
                    userId,
                    conversationId,
                    userText
                  );

                  writer.write({
                    type: 'text-delta',
                    textDelta: revisionMessage,
                  });

                  return part; // Keep tool in input-available state

                } else {
                  // Other validation failures - no recent approval offer
                  console.log(`[NaturalApproval] ‚ùå No valid approval for ${toolName}: ${validationResult.reasoning}`);
                  return part; // Keep tool as is
                }
              }

              // ‚úÖ Validation passed - convert to approved state for HITL processing
              console.log(`[NaturalApproval] ‚úÖ Approval validated for ${toolName} - proceeding with execution`);

              return {
                ...part,
                output: 'Yes, confirmed.',
                state: 'output-available',
                metadata: {
                  ...part.metadata,
                  approvalMethod: 'natural_language',
                  approvalTimestamp: Date.now(),
                  approvalConfidence: validationResult.intent?.confidence || 0,
                }
              };
            })
          );

          // Update the last message with validated parts
          preValidatedMessages = [
            ...preValidatedMessages.slice(0, -1),
            { ...lastMessage, parts: processedParts }
          ];
        }

        // üîß HITL DEBUG: Track tool processing pipeline
        console.log('[Chat API] üéØ Starting tool results processing for approval and artifacts');
        console.log('[Chat API] üìä Input messages count:', preValidatedMessages.length);
        console.log('[Chat API] üîß Phase completion tools available:', Object.keys(phaseCompletionTools));

        // AI SDK v5 HITL INTEGRATION: Process tool results for approval and artifact generation
        let finalProcessedMessages = await processToolResultsForApproval(
          preValidatedMessages,
          writer,
          phaseCompletionTools
        );

        console.log('[Chat API] ‚úÖ Tool results processing completed');
        console.log('[Chat API] üìä Output messages count:', finalProcessedMessages.length);
        console.log('[Chat API] üîç Message parts summary:', finalProcessedMessages.map(m => ({
          id: m.id,
          role: m.role,
          partsCount: m.parts?.length || 0,
          hasArtifacts: m.parts?.some(p => p.type === 'data' && (p.data?.type === 'artifact' || p.value?.type === 'artifact')) || false
        })));

        // üéØ PHASE PROGRESSION CONFIRMATION (client-side tool):
        // If the last assistant message contains a phase_progression_confirm tool
        // with output-available = "Yes, confirmed.", emit gate-closed + phase-update.
        try {
          const lastMsg = finalProcessedMessages[finalProcessedMessages.length - 1] as any;
          const parts = Array.isArray(lastMsg?.parts) ? lastMsg.parts : [];
          for (const part of parts) {
            try {
              if (!isToolUIPart(part)) continue;
              const t = getToolName(part) as string;
              if (t === 'phase_progression_confirm' && part.state === 'output-available') {
                const approved = typeof part.output === 'string' && /^yes/i.test(part.output);
                const proposedNext = Number(part.input?.nextPhase) || Math.min(currentPhase + 1, 7);
                const fromPhase = currentPhase;
                if (approved && proposedNext >= fromPhase && proposedNext <= 7) {
                  // Emit gate-closed for the pseudo-gate of progression confirmation
                  writer.write({
                    type: 'data-gate-closed',
                    id: `gate-closed-${t}-${part.toolCallId || 'unknown'}`,
                    data: {
                      tool: t,
                      phase: fromPhase,
                      toolCallId: part.toolCallId,
                      state: 'completed',
                      artifactGenerated: false,
                      timestamp: Date.now(),
                    },
                  } as any);
                  // Emit phase update to move indicator forward
                  writer.write({
                    type: 'data-phase-update',
                    data: {
                      currentPhase: fromPhase,
                      nextPhase: proposedNext,
                      reason: 'user_confirmation',
                      timestamp: Date.now(),
                    },
                  });
                  console.log(`[Chat API] üì£ Phase progression confirmed by user: ${fromPhase} ‚Üí ${proposedNext}`);
                }
              }
            } catch {}
          }
        } catch (e) {
          console.warn('[Chat API] ‚ö†Ô∏è Phase progression confirm handling failed:', e);
        }

        // ‚ùå REMOVED: Hardcoded phase progression context - all instructions must come from centralized database system prompt

        let modelUsed = dynamicConfig.primaryProvider; // üîß DYNAMIC: Based on database config
        let providerUsed = dynamicConfig.primaryProvider; // üîß DYNAMIC: Based on database config
        let primaryExecuted = false;
        let primarySuccess = false;
        let writerUsed = false;

        try {
          // üöÄ HIGH PRIORITY FIX 1: DYNAMIC EXECUTION PATTERN
          // PRIMARY: Dynamic provider based on database configuration
          console.log(`[Chat API] üîß Using DYNAMIC PRIMARY: ${dynamicConfig.primaryProvider} (from database config)`);
          
          primaryExecuted = true;
          // Debug: Check finalProcessedMessages before conversion
          console.log('[Chat API] üîç DEBUG finalProcessedMessages:', {
            type: typeof finalProcessedMessages,
            isArray: Array.isArray(finalProcessedMessages),
            length: finalProcessedMessages?.length,
            sample: finalProcessedMessages?.[0]
          });

          // üîß P0.1 FIX: Preserve tool parts with updated state for proper HITL workflow
          const debugMessages = Array.isArray(finalProcessedMessages) ? finalProcessedMessages : [];

          // üîß P0.1 FIX: Handle input-available tool parts for approval workflow
          const filteredDebugMessages = debugMessages.map(msg => ({
            ...msg,
            parts: (msg.parts || []).filter(part => {
              // üõë FILTER OUT COMPLETED TOOL PARTS: Prevent AI SDK processing of completed tools
              if (isToolUIPart(part) && (part.state === 'completed' || part.metadata?.executedAt)) {
                const toolName = getToolName(part);
                console.log(`[Chat API] üõë Filtering completed tool part: ${toolName} (state: ${part.state})`);
                return false; // Remove completed tools from AI SDK processing
              }

              // Handle tool parts in input-available state for approval detection
              if (isToolUIPart(part) && part.state === 'input-available') {
                const toolName = getToolName(part);
                console.log(`[Chat API] üîç Processing input-available tool part: ${toolName}`);

                // Check if this is a phase completion tool waiting for approval
                if (toolName?.startsWith('complete_phase_')) {
                  // Check last user message for approval
                  const lastUserMsg = validatedMessages[validatedMessages.length - 1];
                  const userText = extractTextFromMessage(lastUserMsg);
                  const intent = detectApprovalIntent(userText);

                  if (intent.intent === 'approve') {
                    console.log(`[Chat API] ‚úÖ Approval detected for ${toolName}, marking for execution`);
                    // Mark tool for execution via metadata (AI SDK v5 compatible)
                    part.metadata = { ...part.metadata, approvalDetected: true, executeAfterStream: true };
                    // üîß FIX: Return false to prevent approved tools from model processing
                    // They will be executed manually via executeApprovedTools()
                    return false; // Remove approved tools from AI SDK processing
                  } else {
                    console.log(`[Chat API] ‚è≥ Tool ${toolName} awaiting approval, keeping in conversation`);
                    return true; // Keep tool part so model knows it exists
                  }
                } else {
                  console.log(`[Chat API] üîß Non-phase tool in input-available state: ${toolName}`);
                  return false; // Filter non-phase tools in input-available state
                }
              }
              return true;
            })
          }));

          // Use AI SDK v5 convertToModelMessages for proper tool part handling
          let manualMessages;
          try {
            // AI SDK v5 compliant conversion that preserves supported tool parts
            manualMessages = convertToModelMessages(filteredDebugMessages);
            console.log('[Chat API] ‚úÖ Using AI SDK convertToModelMessages with filtered tool parts');
          } catch (conversionError) {
            console.warn('[Chat API] ‚ö†Ô∏è convertToModelMessages failed, using fallback conversion:', conversionError);
            // Fallback: Preserve essential message structure while extracting text
            manualMessages = filteredDebugMessages.map(msg => ({
              role: msg.role,
              content: msg.content || msg.parts?.map(p => p.type === 'text' ? p.text : '').join('') || ''
            }));
          }
          
          console.log('[Chat API] üîç DEBUG manualMessages:', manualMessages);

          // ‚ö° PERFORMANCE: Fire-and-forget persistence to avoid blocking response
          const persistAndBroadcast = () => {
            // Non-blocking - use process.nextTick to defer execution
            process.nextTick(async () => {
              try {
                if (!chatId) return;
                const { saveChat } = await import('../../../src/lib/database/chat-store');
                // üîß P0.1 FIX: Use finalProcessedMessages with updated tool states for persistence
                await saveChat({ chatId, messages: finalProcessedMessages });
                console.log('[Chat API] ‚úÖ Messages persisted asynchronously');

                // ‚ùå REMOVED: Async data-history emission (was emitted after stream closed)
                // Now using synchronous emission right after artifact attachment
                console.log('[Chat API] ‚ÑπÔ∏è Background persistence completed - data-history event emitted synchronously');
              } catch (e) {
                console.error('[Chat API] üö´ Background persistence failed:', e instanceof Error ? e.message : String(e));
                // Silently fail - don't impact user experience
              }
            });
          };
          
          console.log('[Chat API] üõ†Ô∏è Tools enabled: openai.tools.webSearchPreview (Responses API)');

  // AI SDK v5: Phase approval state is handled by processToolCalls automatically
  // üîß NOTE: Phase detection logic moved earlier in the flow for proper progressive tracking

  // üéØ HITL FIX: Use conversation-aware tools based on discussion depth
  const conversationSummary = getConversationSummary(validatedMessages);
  console.log(`[Chat API] üìä Conversation Analysis:`, conversationSummary);

  // Get tools based on conversation depth (implements 3-4 exchange requirement)
  const availableTools = getConversationAwareTools(validatedMessages);
  const toolNames = Object.keys(availableTools);

  console.log(`[Chat API] üîß Available tools based on conversation depth: ${toolNames.join(', ')}`);
  console.log(`[Chat API] üí° Recommendation: ${conversationSummary.recommendation}`);

  // Build primary tools with guard to prevent repeated native web search loops
  const recentAssistant = (() => {
    try {
      const assistants = validatedMessages.filter((m: any) => m.role === 'assistant');
      return assistants[assistants.length - 1];
    } catch { return undefined as any; }
  })();
  const recentAssistantBlob = JSON.stringify((recentAssistant as any)?.parts || (recentAssistant as any)?.content || '');
  const recentUsedNativeSearch = /web_search_preview/i.test(recentAssistantBlob) || /web\s*search/i.test(recentAssistantBlob);
  const lastUser = (() => {
    try {
      const users = validatedMessages.filter((m: any) => m.role === 'user');
      return users[users.length - 1];
    } catch { return undefined as any; }
  })();
  const lastUserText = (() => {
    try {
      if (!lastUser) return '';
      if (typeof (lastUser as any).content === 'string') return ((lastUser as any).content as string) || '';
      if (Array.isArray((lastUser as any).parts)) {
        return (lastUser as any).parts.filter((p: any) => p?.type === 'text').map((p: any) => p.text).join('\n');
      }
      return '';
    } catch { return ''; }
  })().toLowerCase();
  const userExplicitMoreSearch = /cari\s+lagi|lanjut\s+(cari|riset|search)|search\s+again|teruskan\s+pencarian/i.test(lastUserText);
  const includeNativeWebSearch = !recentUsedNativeSearch || userExplicitMoreSearch;

  const toolsForPrimary = {
    ...(includeNativeWebSearch ? { web_search_preview: (openai as any).tools.webSearchPreview({ searchContextSize: 'high' }) } : {}),
    // Filter out custom web_search to prevent duplication with native OpenAI search
    ...Object.fromEntries(
      Object.entries(availableTools).filter(([key]) => key !== 'web_search')
    ),
  } as Record<string, any>;

  // üîß HITL DEBUG: Track primary model configuration and tool setup
  console.log('[Chat API] üöÄ Initializing primary model streamText');
  console.log('[Chat API] üõ†Ô∏è Tools for primary model:', Object.keys(toolsForPrimary));
  console.log('[Chat API] ‚öôÔ∏è Native web search included:', includeNativeWebSearch);
  console.log('[Chat API] üéØ Tool choice setting:', testMode ? 'web_search_preview (test mode)' : 'undefined (model decides)');
  console.log('[Chat API] üìä Manual messages count:', manualMessages.length);

  // Determine which model to use for web search
  let streamModel;
  let streamTools = toolsForPrimary;

  if (dynamicConfig.webSearchProvider === 'perplexity' && dynamicConfig.webSearchModel) {
    console.log('[Chat API] üåê Using Perplexity for web search');
    streamModel = dynamicConfig.webSearchModel;
    // Perplexity has built-in web search, don't need web_search_preview tool
    streamTools = Object.fromEntries(
      Object.entries(availableTools).filter(([key]) => key !== 'web_search')
    );
  } else {
    console.log('[Chat API] üåê Using OpenAI Responses API for web search');
    // Force OpenAI Responses for native web search
    streamModel = (openai as any).responses(dynamicConfig.primaryModelName || process.env.OPENAI_MODEL || 'gpt-4o');
  }

  const result = streamText({
            model: streamModel,
            messages: manualMessages,
            system: systemPrompt,
            // Dynamic tools based on conversation depth (HITL compliance)
            tools: streamTools,
            // üõë HITL FIX: Allow natural conversation flow - no forced tool execution
            // Agent should engage in discussion first, then naturally choose tools when appropriate
            toolChoice: testMode
              ? { type: 'tool', toolName: 'web_search_preview' } // Test mode only
              : undefined, // üîß HITL FIX: Let model decide naturally, enable proper approval flow for phase tools
            temperature: dynamicConfig.config.temperature,
            maxRetries: 3,
            frequencyPenalty: dynamicConfig.config.frequencyPenalty,
            presencePenalty: dynamicConfig.config.presencePenalty,
          });

          // Citations streaming disabled for stability; sources available via debug endpoint
          
          console.log('[Chat API] ‚úÖ Native OpenAI web search initialized');

          // üîß RATE LIMIT FIX: Check for rate limit BEFORE merging stream
          // This ensures fallback can still trigger if rate limit is hit
          try {
            // Create a promise race between response and immediate rate limit check
            const responsePromise = result.response;

            // Quick check for immediate rate limit errors
            await Promise.race([
              responsePromise,
              new Promise((_, reject) => {
                setTimeout(() => {
                  // Give it 100ms to detect immediate rate limit
                }, 100);
              })
            ]).catch(async (immediateError: any) => {
              // Check if it's a rate limit error
              if (immediateError?.error?.code === 'rate_limit_exceeded' ||
                  immediateError?.message?.includes('rate_limit') ||
                  immediateError?.toString?.().includes('rate_limit')) {
                console.error('[Chat API] ‚ö†Ô∏è IMMEDIATE rate limit detected - skipping primary stream merge');
                throw immediateError; // Skip stream merge, go to fallback
              }
              // Other immediate errors - still try to continue
              console.warn('[Chat API] ‚ö†Ô∏è Non-rate-limit immediate error, continuing:', immediateError);
            });

            // üîß HITL FIX: Execute approved tools before merging stream
            await executeApprovedTools(filteredDebugMessages, writer, phaseCompletionTools);

            // If no immediate rate limit, merge the stream
            if (!writerUsed) {
              writer.merge(result.toUIMessageStream({
                originalMessages: finalProcessedMessages,
                sendFinish: true // ‚úÖ FIXED: Allow stream to properly complete
              }));
              writerUsed = true;
              console.log('[Chat API] ‚úÖ Primary stream merged with proper completion');
            }

            // Wait for full response completion
            const response = await responsePromise;
            primarySuccess = true;
            console.log('[Chat API] ‚úÖ Primary execution FULLY completed - fallback will be blocked');

          } catch (responseError: any) {
            // Check if it's a rate limit error
            if (responseError?.error?.code === 'rate_limit_exceeded' ||
                responseError?.message?.includes('rate_limit') ||
                responseError?.toString?.().includes('rate_limit')) {
              console.error('[Chat API] ‚ö†Ô∏è Primary provider hit rate limit:', {
                message: responseError?.error?.message || responseError?.message || 'Rate limit exceeded',
                provider: dynamicConfig.primaryProvider,
                model: dynamicConfig.primaryModelName,
                writerUsed // Log whether stream was already merged
              });
              // Don't set primarySuccess = true, allowing fallback to trigger
              throw responseError; // Re-throw to trigger fallback in outer catch
            } else {
              // Other errors - still mark as failure
              console.error('[Chat API] ‚ùå Primary provider response error:', responseError);
              throw responseError;
            }
          }

          // üîÑ TASK 03 DATABASE INTEGRATION: Fire-and-forget message persistence
          // CRITICAL: Only runs AFTER primarySuccess = true to ensure stream completion
          // NOTE: Removed redundant persistAndBroadcast() to prevent double persistence
          try {
            const { persistMessagesAsync } = await import('../../../src/lib/database/message-persistence');
            
            // Generate session ID for persistence tracking
            const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Fire-and-forget async persistence with broadcast
            // Persist the validated/processed messages so metadata.phase tersimpan benar
            persistMessagesAsync(finalProcessedMessages || validatedMessages, {
              conversationId: chatId, // Use chatId from X-Chat-Id header
              userId, // Dynamic user ID from authenticated session (Task 13-6 fix)
              phase: currentPhase,
              sessionId,
              streamCoordinationData: {
                primaryExecuted,
                primarySuccess,
                writerUsed
              }
            }).then(() => {
              try {
                if (writer && typeof writer.write === 'function') {
                  writer.write({
                    type: 'data-history',
                    data: { chatId, refresh: true, timestamp: Date.now(), reason: 'persistence_complete' },
                  });
                  console.log('[Chat API] üì£ SYNCHRONOUS data-history event emitted (reason: persistence_complete)');
                }
              } catch {}
              console.log('[Chat API] ‚ÑπÔ∏è Message persistence completed');
            }).catch((error) => {
              console.error('[Chat API] ‚ö†Ô∏è Persistence failed:', error);
            });

            console.log('[Chat API] üîÑ Initiated async message persistence (fire-and-forget)');
            // üì£ Emit data-history immediately to allow frontend reload (even without approval)
            try {
              writer.write({
                type: 'data-history',
                data: { chatId, refresh: true, timestamp: Date.now(), reason: 'phase_update' },
              });
              console.log('[Chat API] üì£ SYNCHRONOUS data-history event emitted (reason: phase_update)');
            } catch (emitErr) {
              console.warn('[Chat API] ‚ö†Ô∏è Failed to emit data-history (phase_update):', emitErr);
            }
          } catch (persistenceError) {
            // ERROR ISOLATION: Don't let persistence errors affect main chat flow
            console.error('[Chat API] ‚ö†Ô∏è Message persistence init failed (isolated):', persistenceError);
          }

          // ‚úÖ Artifact streaming + persistence after approval (non‚Äëblocking, minimal)
          try {
            if (phaseApprovalContext?.approved) {
              // Global deduplication guard for artifact generation
              const approvalKey = `${chatId}:phase_${phaseApprovalContext.phase}:approved`;

              // Check if we've already processed this approval to prevent duplicates
              if (globalThis.processedApprovals?.has(approvalKey)) {
                console.log(`[Chat API] ‚ö†Ô∏è Approval for phase ${phaseApprovalContext.phase} already processed, skipping duplicate artifact generation`);
                return; // Skip artifact generation for duplicate approval
              }

              // Initialize global approval tracking
              if (!globalThis.processedApprovals) {
                globalThis.processedApprovals = new Set();
              }
              globalThis.processedApprovals.add(approvalKey);

              // Build minimal artifact payload from approval input (no model/tool changes)
              const artifactId = `artifact_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              const phaseNumber = Number(phaseApprovalContext.phase) || currentPhase || 1;
              const title = `Ringkasan Fase ${phaseNumber}`;
              const input = (phaseApprovalContext as any).input || {};

              // Simple markdown content based on approved deliverables
              const lines: string[] = [];
              lines.push(`# Ringkasan Fase ${phaseNumber}`);
              lines.push("");
              lines.push("Hasil fase yang disetujui:");
              lines.push("");
              const keys = Object.keys(input);
              if (keys.length > 0) {
                for (const k of keys) {
                  const val = typeof input[k] === 'string' ? input[k] : JSON.stringify(input[k]);
                  lines.push(`- ${k.replace(/_/g, ' ')}: ${val}`);
                }
              } else {
                lines.push("- (Tidak ada detail tambahan dari approval tool)");
              }
              lines.push("");
              lines.push("Catatan: Artifact ini diringkas dari data approval fase.");

              const content = lines.join("\n");
              const wordCount = content.split(/\s+/).filter(Boolean).length;

              // Stream artifact to client for immediate UI rendering
              writer.write({
                type: 'data-artifact',
                data: {
                  type: 'artifact',
                  id: artifactId,
                  title,
                  content,
                  metadata: {
                    phase: phaseNumber,
                    wordCount,
                    lastModified: Date.now(),
                    tags: [] as string[],
                  },
                },
              });

              // Persist artifact by attaching to last assistant message (best‚Äëeffort, isolated)
              try {
                const { updateMessageWithArtifact } = await import('../../../src/lib/database/message-persistence');

                // Longer delay to allow main message persistence to complete
                await new Promise((r) => setTimeout(r, 500));

                if (chatId) {
                  const lastAssistant = messages.slice().reverse().find((m) => m.role === 'assistant');
                  if (lastAssistant) {
                    // Check if artifact is already approved to prevent double attachment
                    const artifactKey = `${chatId}:${lastAssistant.id}:${artifactId}`;

                    await updateMessageWithArtifact(chatId, lastAssistant.id, {
                      type: 'artifact',
                      id: artifactId,
                      title,
                      content,
                      metadata: {
                        phase: phaseNumber,
                        wordCount,
                        lastModified: Date.now(),
                        tags: [] as string[],
                      },
                    });
                    console.log(`[Chat API] ‚úÖ Artifact attached to message ${lastAssistant.id}`);

                    // üöÄ CRITICAL FIX: Emit data-history event synchronously while writer still active
                    // This ensures frontend receives the event and can reload messages with artifacts
                    try {
                      if (writer && typeof writer.write === 'function') {
                        writer.write({
                          type: 'data-history',
                          data: { chatId, refresh: true, timestamp: Date.now(), reason: 'artifact_attached' }
                        });
                        console.log('[Chat API] üì£ SYNCHRONOUS data-history event emitted after artifact attachment');
                      }
                    } catch (emitErr) {
                      console.warn('[Chat API] ‚ö†Ô∏è Failed to emit synchronous data-history event:', emitErr);
                    }
                  } else {
                    console.log('[Chat API] ‚ÑπÔ∏è No assistant message found to attach artifact');
                  }
                } else {
                  console.log('[Chat API] ‚ÑπÔ∏è chatId missing; skip artifact DB attachment');
                }
              } catch (artifactPersistError) {
                console.error('[Chat API] ‚ö†Ô∏è Artifact persistence failed (isolated):', artifactPersistError);
              }
            }
          } catch (artifactError) {
            // Error isolation: artifact issues must not break main chat flow
            console.error('[Chat API] ‚ö†Ô∏è Artifact streaming error (isolated):', artifactError);
          }

        } catch (primaryError) {
          console.error('[Chat API] ‚ùå Primary provider failed:', {
            error: primaryError instanceof Error ? primaryError.message : String(primaryError),
            phase,
            messageCount: messages.length,
            primaryExecuted,
            primarySuccess
          });
          
          // üîß ENHANCED ERROR BOUNDARY - STRICT FALLBACK CONDITION  
          // ONLY execute fallback if primary truly failed AND no writer was used
          if (!primarySuccess && !writerUsed) {
            console.log('[Chat API] üîÑ PRIMARY FAILED (no output generated) - Initiating fallback to OpenRouter Gemini');
          
            // Initialize custom tools only for fallback (disabled for stability)
            const fallbackTools = {} as Record<string, any>;
            console.log(`[Chat API] üõ†Ô∏è Fallback tools disabled in this build`);
            
            modelUsed = `${dynamicConfig.fallbackProvider}-fallback`;
            providerUsed = `${dynamicConfig.fallbackProvider}-fallback`;
        
            // Fallback uses same system prompt from database

            try {
              const fallbackModel = dynamicConfig.fallbackModel;
              console.log('[Chat API] Fallback model initialized successfully');
              
              // Debug: Check finalProcessedMessages before fallback conversion
              console.log('[Chat API] üîç DEBUG FALLBACK finalProcessedMessages:', {
                type: typeof finalProcessedMessages,
                isArray: Array.isArray(finalProcessedMessages),
                length: finalProcessedMessages?.length,
                sample: finalProcessedMessages?.[0]
              });

              // DEBUG: Manual message conversion for fallback to bypass filter() error
              const fallbackDebugMessages = Array.isArray(finalProcessedMessages) ? finalProcessedMessages : [];
              const fallbackManualMessages = fallbackDebugMessages.map(msg => ({
                role: msg.role,
                content: msg.content || msg.parts?.map(p => p.type === 'text' ? p.text : '').join('') || ''
              }));
              
              console.log('[Chat API] üîç DEBUG FALLBACK manualMessages:', fallbackManualMessages);
              
              // üéØ HITL FIX: Use same conversation-aware tools for fallback consistency

              const fallbackResult = streamText({
                model: fallbackModel,
                messages: fallbackManualMessages,
                system: systemPrompt,
                temperature: dynamicConfig.config.temperature,
                maxRetries: 2,
                // Use same conversation-aware tools as primary for consistency
                tools: {
                  ...fallbackTools, // Custom web search tools for fallback
                  ...availableTools, // Same conversation-aware tools as primary
                  ...fileTools, // File upload and processing tools for consistency
                  ...citationTools, // Citation analysis tools for consistency
                },
                toolChoice: 'auto',
                stopWhen: stepCountIs(3), // üîß MEDIUM PRIORITY FIX 4: ALIGNED multi-step count with primary
              });
              
              console.log('[Chat API] ‚úÖ Fallback provider streaming initialized');
              
              // üîß HIGH PRIORITY FIX 3: SINGLE WRITER PATH - Fallback execution only if primary failed
              if (!writerUsed) {
                writer.merge(fallbackResult.toUIMessageStream({ 
                  originalMessages: finalProcessedMessages,
                  sendStart: false // Coordinate with any previous stream attempts
                }));
                writerUsed = true;
                console.log('[Chat API] ‚úÖ Fallback stream merged - exclusive execution');
                
                // üîÑ TASK 03 DATABASE INTEGRATION: Fire-and-forget message persistence (fallback path)
                try {
                  const { persistMessagesAsync } = await import('../../../src/lib/database/message-persistence');
                  
                  // Generate session ID for persistence tracking
                  const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                  
                  // Fire-and-forget async persistence (won't block or interfere with response)
                  // Fallback persistence should also store validated messages for correct metadata
                  persistMessagesAsync(finalProcessedMessages || validatedMessages, {
                    conversationId: chatId, // Use chatId from X-Chat-Id header
                    userId, // Dynamic user ID from authenticated session (Task 13-6 fix)
                    phase: currentPhase,
                    sessionId,
                    streamCoordinationData: {
                      primaryExecuted,
                      primarySuccess: false, // Fallback path, so primary failed
                      writerUsed
                    }
                  });
                  
                  console.log('[Chat API] üîÑ Initiated async message persistence (fallback, fire-and-forget)');
                } catch (persistenceError) {
                  // ERROR ISOLATION: Don't let persistence errors affect main chat flow
                  console.error('[Chat API] ‚ö†Ô∏è Message persistence init failed (fallback, isolated):', persistenceError);
                }
              } else {
                console.log('[Chat API] ‚ö†Ô∏è Writer already used - skipping fallback merge to prevent double output');
              }

              // Fallback artifact generation disabled in this smoke-test build
              
            } catch (fallbackError) {
              console.error('[Chat API] üí• Both providers failed:', {
                primaryError: primaryError instanceof Error ? primaryError.message : String(primaryError),
                fallbackError: fallbackError instanceof Error ? fallbackError.message : String(fallbackError),
                phase,
                writerUsed
              });
              
              const primaryMsg = primaryError instanceof Error ? primaryError.message : String(primaryError);
              const fallbackMsg = fallbackError instanceof Error ? fallbackError.message : String(fallbackError);
              throw new Error(`Both AI providers failed: Primary (${primaryMsg}), Fallback (${fallbackMsg})`);
            }
          } else if (primarySuccess && writerUsed) {
            console.log('[Chat API] ‚úÖ Primary succeeded with output - fallback execution BLOCKED');
          } else {
            console.log('[Chat API] ‚ö†Ô∏è Unexpected state - no fallback needed');
          }
        }
      },
    });

    // üîß HITL DEBUG: Final request summary
    console.log('[Chat API] üéØ REQUEST COMPLETED SUCCESSFULLY');
    console.log('[Chat API] üìä Final request summary:', {
      userId: userId?.substring(0, 8) + '...',
      requestId: (req as any).requestId || 'unknown',
      currentPhase: currentPhase, // üîß FIXED: Use available currentPhase variable
      messagesProcessed: validatedMessages.length,
      primaryProviderUsed: dynamicConfig.primaryModelName,
      fallbackUsed: false, // This path is primary success
      streamInitialized: true,
      timestamp: new Date().toISOString()
    });
    console.log('[Chat API] ‚úÖ Returning createUIMessageStreamResponse with HITL integration');

    // Return createUIMessageStreamResponse as per AI SDK v5 documentation
    return createUIMessageStreamResponse({ stream });
    
  } catch (error) {
    console.error('[Chat API] üí• Fatal API error:', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString(),
      request_info: {
        method: 'POST',
        url: '/api/chat'
      }
    });
    
    return new Response(JSON.stringify({
      error: error instanceof Error ? error.message : 'Internal server error',
      provider_status: 'both_unavailable',
      timestamp: Date.now(),
      suggestion: 'Please try again. If the issue persists, both AI providers may be temporarily unavailable.',
    }), {
      status: 500,
      headers: { 
        'Content-Type': 'application/json',
        'X-Provider-Status': 'error'
      },
    });
  }
}

// Helper function to get phase description
function getPhaseDescription(phase: number): string {
  const phases = [
    '', // 0 - not used
    'Scope Definition & Research Planning - Define topic, scope, research questions',
    'Literature Review & Data Collection - Discuss search approach and methodology', 
    'Outlining & Structure Planning - Explore structure options and develop collaboratively',
    'Writing & Drafting - WRITE substantial content with academic structure',
    'Citation & Reference Management - INTEGRATE citations and format references',
    'Review & Quality Assurance - REVIEW content quality and completeness',
    'Final Editing & Submission Preparation - FORMAT for publication submission'
  ];
  
  return phases[phase] || 'Unknown Phase';
}
